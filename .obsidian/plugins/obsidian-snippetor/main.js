/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[Object.keys(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  __markAsModule(target);
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toModule = (module2) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve2, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve2(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// node_modules/random-word-slugs/dist/words.js
var require_words = __commonJS({
  "node_modules/random-word-slugs/dist/words.js"(exports) {
    "use strict";
    var __values = exports && exports.__values || function(o) {
      var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
      if (m)
        return m.call(o);
      if (o && typeof o.length === "number")
        return {
          next: function() {
            if (o && i >= o.length)
              o = void 0;
            return { value: o && o[i++], done: !o };
          }
        };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getWordsByCategory = exports.wordList = void 0;
    exports.wordList = {
      noun: [
        { word: "accountant", categories: ["profession"] },
        { word: "ability", categories: ["thing"] },
        { word: "accident", categories: ["thing"] },
        { word: "account", categories: ["thing"] },
        { word: "action", categories: ["thing"] },
        { word: "activity", categories: ["thing"] },
        { word: "actor", categories: ["profession"] },
        { word: "ad", categories: ["media"] },
        { word: "addition", categories: ["thing"] },
        { word: "address", categories: ["thing"] },
        { word: "adult", categories: ["people"] },
        { word: "advantage", categories: ["thing"] },
        { word: "advertisement", categories: ["media"] },
        { word: "afternoon", categories: ["time"] },
        { word: "agency", categories: ["thing"] },
        { word: "agent", categories: ["people"] },
        { word: "air", categories: ["thing"] },
        { word: "airline", categories: ["transportation"] },
        { word: "airplane", categories: ["transportation"] },
        { word: "airport", categories: ["transportation", "place"] },
        { word: "alarm", categories: ["thing"] },
        { word: "alligator", categories: ["animals"] },
        { word: "ambulance", categories: ["health"] },
        { word: "analyst", categories: ["profession"] },
        { word: "angle", categories: ["thing"] },
        { word: "animal", categories: ["animals"] },
        { word: "answer", categories: ["thing"] },
        { word: "apartment", categories: ["place"] },
        { word: "apple", categories: ["food"] },
        { word: "application", categories: ["thing"] },
        { word: "appointment", categories: ["thing"] },
        { word: "architect", categories: ["profession"] },
        { word: "argument", categories: ["thing"] },
        { word: "area", categories: ["thing"] },
        { word: "arm", categories: ["thing"] },
        { word: "army", categories: ["thing"] },
        { word: "art", categories: ["thing"] },
        { word: "article", categories: ["thing"] },
        { word: "artist", categories: ["profession"] },
        { word: "australia", categories: ["place"] },
        { word: "author", categories: ["profession"] },
        { word: "autumn", categories: ["time"] },
        { word: "baby", categories: ["people", "family"] },
        { word: "baker", categories: ["profession"] },
        { word: "balloon", categories: ["thing"] },
        { word: "banana", categories: ["food"] },
        { word: "barista", categories: ["profession"] },
        { word: "battery", categories: ["thing"] },
        { word: "beach", categories: ["place"] },
        { word: "bear", categories: ["animals"] },
        { word: "beard", categories: ["thing"] },
        { word: "bed", categories: ["thing"] },
        { word: "belgium", categories: ["place"] },
        { word: "bird", categories: ["animals"] },
        { word: "bit", categories: ["thing", "technology"] },
        { word: "book", categories: ["thing", "education"] },
        { word: "boots", categories: ["thing"] },
        { word: "boy", categories: ["people"] },
        { word: "branch", categories: ["thing"] },
        { word: "breakfast", categories: ["thing"] },
        { word: "brother", categories: ["family"] },
        { word: "businessperson", categories: ["people", "business"] },
        { word: "butcher", categories: ["profession"] },
        { word: "byte", categories: ["thing", "technology"] },
        { word: "camera", categories: ["thing"] },
        { word: "candle", categories: ["thing"] },
        { word: "car", categories: ["transportation"] },
        { word: "caravan", categories: ["transportation"] },
        { word: "carpenter", categories: ["profession"] },
        { word: "carpet", categories: ["thing"] },
        { word: "cartoon", categories: ["media"] },
        { word: "cat", categories: ["animals"] },
        { word: "chef", categories: ["profession"] },
        { word: "child", categories: ["people", "family"] },
        { word: "china", categories: ["place"] },
        { word: "church", categories: ["religion"] },
        { word: "city", categories: ["place"] },
        { word: "coat", categories: ["thing"] },
        { word: "coffeeshop", categories: ["place"] },
        { word: "computer", categories: ["thing", "technology"] },
        { word: "continent", categories: ["place"] },
        { word: "controller", categories: ["thing", "technology"] },
        { word: "country", categories: ["place"] },
        { word: "cpu", categories: ["thing", "technology"] },
        { word: "crayon", categories: ["thing"] },
        { word: "cricket", categories: ["animals"] },
        { word: "crowd", categories: ["people"] },
        { word: "daughter", categories: ["family"] },
        { word: "dawn", categories: ["time"] },
        { word: "daybreak", categories: ["time"] },
        { word: "death", categories: ["thing"] },
        { word: "denmark", categories: ["place"] },
        { word: "dentist", categories: ["profession"] },
        { word: "diamond", categories: ["thing"] },
        { word: "dinner", categories: ["food"] },
        { word: "disease", categories: ["thing"] },
        { word: "doctor", categories: ["profession"] },
        { word: "dog", categories: ["animals"] },
        { word: "dream", categories: ["thing"] },
        { word: "dress", categories: ["thing"] },
        { word: "dusk", categories: ["time"] },
        { word: "easter", categories: ["religion"] },
        { word: "egg", categories: ["food"] },
        { word: "eggplant", categories: ["food"] },
        { word: "egypt", categories: ["place"] },
        { word: "electrician", categories: ["profession"] },
        { word: "elephant", categories: ["animals"] },
        { word: "energy", categories: ["thing"] },
        { word: "engine", categories: ["transportation"] },
        { word: "engineer", categories: ["profession"] },
        { word: "england", categories: ["place"] },
        { word: "eve", categories: ["time"] },
        { word: "evening", categories: ["time"] },
        { word: "eventide", categories: ["time"] },
        { word: "exabyte", categories: ["thing", "technology"] },
        { word: "eye", categories: ["thing"] },
        { word: "fall", categories: ["time"] },
        { word: "family", categories: ["family"] },
        { word: "farmer", categories: ["profession"] },
        { word: "father", categories: ["people", "family"] },
        { word: "finland", categories: ["place"] },
        { word: "fireman", categories: ["profession"] },
        { word: "fish", categories: ["animals"] },
        { word: "flag", categories: ["thing"] },
        { word: "florist", categories: ["profession"] },
        { word: "flower", categories: ["thing"] },
        { word: "football", categories: ["sports"] },
        { word: "forest", categories: ["place"] },
        { word: "fountain", categories: ["thing"] },
        { word: "france", categories: ["place"] },
        { word: "furniture", categories: ["thing"] },
        { word: "garage", categories: ["place"] },
        { word: "garden", categories: ["food"] },
        { word: "gas", categories: ["transportation"] },
        { word: "ghost", categories: ["thing"] },
        { word: "gigabyte", categories: ["thing", "technology"] },
        { word: "girl", categories: ["people"] },
        { word: "glass", categories: ["thing"] },
        { word: "gold", categories: ["thing"] },
        { word: "gpu", categories: ["thing", "technology"] },
        { word: "grandmother", categories: ["people", "family"] },
        { word: "grass", categories: ["thing"] },
        { word: "greece", categories: ["place"] },
        { word: "guitar", categories: ["thing"] },
        { word: "hair", categories: ["thing"] },
        { word: "hairdresser", categories: ["profession"] },
        { word: "hamburger", categories: ["food"] },
        { word: "helicopter", categories: ["transportation"] },
        { word: "helmet", categories: ["thing"] },
        { word: "holiday", categories: ["thing"] },
        { word: "honey", categories: ["food"] },
        { word: "horse", categories: ["animals"] },
        { word: "hospital", categories: ["place"] },
        { word: "house", categories: ["place"] },
        { word: "hydrogen", categories: ["science"] },
        { word: "ice", categories: ["science"] },
        { word: "insect", categories: ["animals"] },
        { word: "insurance", categories: ["thing"] },
        { word: "intern", categories: ["profession"] },
        { word: "iron", categories: ["science"] },
        { word: "island", categories: ["place"] },
        { word: "jackal", categories: ["animals"] },
        { word: "jelly", categories: ["food"] },
        { word: "jewellery", categories: ["thing"] },
        { word: "jordan", categories: ["place"] },
        { word: "journalist", categories: ["profession"] },
        { word: "joystick", categories: ["thing", "technology"] },
        { word: "judge", categories: ["profession"] },
        { word: "juice", categories: ["food"] },
        { word: "kangaroo", categories: ["animals"] },
        { word: "keyboard", categories: ["thing", "technology"] },
        { word: "kilobyte", categories: ["thing", "technology"] },
        { word: "king", categories: ["people"] },
        { word: "kitchen", categories: ["place"] },
        { word: "kite", categories: ["thing"] },
        { word: "knife", categories: ["thing"] },
        { word: "lamp", categories: ["thing"] },
        { word: "laptop", categories: ["thing", "technology"] },
        { word: "lawyer", categories: ["profession"] },
        { word: "leather", categories: ["thing"] },
        { word: "librarian", categories: ["profession"] },
        { word: "library", categories: ["place"] },
        { word: "lifeguard", categories: ["profession"] },
        { word: "lighter", categories: ["thing"] },
        { word: "lion", categories: ["animals"] },
        { word: "lizard", categories: ["animals"] },
        { word: "lock", categories: ["thing"] },
        { word: "london", categories: ["place"] },
        { word: "lunch", categories: ["food"] },
        { word: "machine", categories: ["science"] },
        { word: "magazine", categories: ["media"] },
        { word: "magician", categories: ["people"] },
        { word: "man", categories: ["people"] },
        { word: "manchester", categories: ["place"] },
        { word: "market", categories: ["place"] },
        { word: "match", categories: ["thing"] },
        { word: "mechanic", categories: ["profession"] },
        { word: "megabyte", categories: ["thing", "technology"] },
        { word: "memory", categories: ["thing", "technology"] },
        { word: "microphone", categories: ["thing"] },
        { word: "midnight", categories: ["time"] },
        { word: "minister", categories: ["people", "religion"] },
        { word: "monitor", categories: ["thing", "technology"] },
        { word: "monkey", categories: ["animals"] },
        { word: "morn", categories: ["time"] },
        { word: "morning", categories: ["time"] },
        { word: "mother", categories: ["people", "family"] },
        { word: "motherboard", categories: ["thing", "technology"] },
        { word: "motorcycle", categories: ["transportation"] },
        { word: "mouse", categories: ["thing", "technology", "animals"] },
        { word: "musician", categories: ["profession"] },
        { word: "nail", categories: ["thing"] },
        { word: "napkin", categories: ["thing"] },
        { word: "needle", categories: ["thing"] },
        { word: "nest", categories: ["thing"] },
        { word: "nigeria", categories: ["place"] },
        { word: "night", categories: ["time"] },
        { word: "nightfall", categories: ["time"] },
        { word: "noon", categories: ["time"] },
        { word: "notebook", categories: ["thing"] },
        { word: "nurse", categories: ["profession"] },
        { word: "ocean", categories: ["place"] },
        { word: "oil", categories: ["thing"] },
        { word: "optician", categories: ["profession"] },
        { word: "orange", categories: ["food"] },
        { word: "oxygen", categories: ["science"] },
        { word: "oyster", categories: ["animals"] },
        { word: "pager", categories: ["thing", "technology"] },
        { word: "painter", categories: ["profession"] },
        { word: "painting", categories: ["media"] },
        { word: "park", categories: ["place"] },
        { word: "parrot", categories: ["animals"] },
        { word: "pencil", categories: ["thing", "education"] },
        { word: "petabyte", categories: ["thing", "technology"] },
        { word: "pharmacist", categories: ["profession"] },
        { word: "photographer", categories: ["profession"] },
        { word: "piano", categories: ["thing"] },
        { word: "pillow", categories: ["thing"] },
        { word: "pilot", categories: ["profession"] },
        { word: "pizza", categories: ["food"] },
        { word: "planet", categories: ["science"] },
        { word: "plastic", categories: ["thing"] },
        { word: "plumber", categories: ["profession"] },
        { word: "policeman", categories: ["profession"] },
        { word: "portugal", categories: ["place"] },
        { word: "postman", categories: ["profession"] },
        { word: "potato", categories: ["food"] },
        { word: "printer", categories: ["thing", "technology"] },
        { word: "processor", categories: ["thing", "technology"] },
        { word: "psychiatrist", categories: ["profession"] },
        { word: "queen", categories: ["people"] },
        { word: "quill", categories: ["thing"] },
        { word: "rain", categories: ["thing"] },
        { word: "rainbow", categories: ["science"] },
        { word: "raincoat", categories: ["thing"] },
        { word: "ram", categories: ["thing", "technology"] },
        { word: "receptionist", categories: ["profession"] },
        { word: "refrigerator", categories: ["food"] },
        { word: "restaurant", categories: ["place"] },
        { word: "river", categories: ["thing"] },
        { word: "rocket", categories: ["science"] },
        { word: "room", categories: ["place"] },
        { word: "rose", categories: ["thing"] },
        { word: "russia", categories: ["place"] },
        { word: "salesclerk", categories: ["people", "business"] },
        { word: "salesmen", categories: ["profession"] },
        { word: "sandwich", categories: ["food"] },
        { word: "school", categories: ["education"] },
        { word: "scientist", categories: ["profession"] },
        { word: "scooter", categories: ["transportation"] },
        { word: "secretary", categories: ["profession"] },
        { word: "shampoo", categories: ["thing"] },
        { word: "shoe", categories: ["thing"] },
        { word: "smartphone", categories: ["thing", "technology"] },
        { word: "soccer", categories: ["sports"] },
        { word: "solstice", categories: ["time"] },
        { word: "spoon", categories: ["thing"] },
        { word: "spring", categories: ["time"] },
        { word: "state", categories: ["place"] },
        { word: "stone", categories: ["thing"] },
        { word: "student", categories: ["people", "education"] },
        { word: "sugar", categories: ["food"] },
        { word: "summer", categories: ["time"] },
        { word: "sundown", categories: ["time"] },
        { word: "sunset", categories: ["time"] },
        { word: "sweden", categories: ["place"] },
        { word: "table", categories: ["thing"] },
        { word: "tailor", categories: ["profession"] },
        { word: "teacher", categories: ["people", "education", "profession"] },
        { word: "teenager", categories: ["people", "family"] },
        { word: "telephone", categories: ["thing"] },
        { word: "television", categories: ["media"] },
        { word: "tent", categories: ["thing"] },
        { word: "terabyte", categories: ["thing", "technology"] },
        { word: "thailand", categories: ["place"] },
        { word: "tiger", categories: ["animals"] },
        { word: "toddler", categories: ["people", "family"] },
        { word: "tomato", categories: ["food"] },
        { word: "toothbrush", categories: ["thing"] },
        { word: "traffic", categories: ["thing"] },
        { word: "train", categories: ["transportation"] },
        { word: "translator", categories: ["profession"] },
        { word: "truck", categories: ["thing", "transportation"] },
        { word: "twilight", categories: ["time"] },
        { word: "uganda", categories: ["place"] },
        { word: "umbrella", categories: ["thing"] },
        { word: "van", categories: ["transportation"] },
        { word: "vase", categories: ["thing"] },
        { word: "vegetable", categories: ["food"] },
        { word: "vr", categories: ["thing", "technology"] },
        { word: "vulture", categories: ["animals"] },
        { word: "waiter", categories: ["profession"] },
        { word: "waitress", categories: ["profession"] },
        { word: "wall", categories: ["thing"] },
        { word: "whale", categories: ["animals"] },
        { word: "window", categories: ["thing"] },
        { word: "winter", categories: ["time"] },
        { word: "wire", categories: ["thing"] },
        { word: "wolf", categories: ["animals"] },
        { word: "woman", categories: ["people"] },
        { word: "xylophone", categories: ["thing"] },
        { word: "yacht", categories: ["transportation"] },
        { word: "yak", categories: ["animals"] },
        { word: "yottabyte", categories: ["thing", "technology"] },
        { word: "zebra", categories: ["animals"] },
        { word: "zettabyte", categories: ["thing", "technology"] },
        { word: "zoo", categories: ["animals"] }
      ],
      adjective: [
        { word: "abandoned", categories: ["condition"] },
        { word: "abiding", categories: ["personality"] },
        { word: "able", categories: ["condition"] },
        { word: "abrasive", categories: ["condition", "personality"] },
        { word: "abnormal", categories: ["condition"] },
        { word: "absurd", categories: ["condition"] },
        { word: "abundant", categories: ["quantity"] },
        { word: "acceptable", categories: ["condition"] },
        { word: "acidic", categories: ["taste"] },
        { word: "acoustic", categories: ["sounds"] },
        { word: "acrid", categories: ["condition"] },
        { word: "adamant", categories: ["personality"] },
        { word: "adorable", categories: ["personality"] },
        { word: "adventurous", categories: ["personality"] },
        { word: "aggressive", categories: ["personality"] },
        { word: "agitated", categories: ["personality"] },
        { word: "agreeable", categories: ["personality"] },
        { word: "alert", categories: ["condition"] },
        { word: "alive", categories: ["condition"] },
        { word: "aloof", categories: ["personality"] },
        { word: "ambitious", categories: ["personality"] },
        { word: "ancient", categories: ["time"] },
        { word: "angry", categories: ["personality"] },
        { word: "annoyed", categories: ["personality"] },
        { word: "antsy", categories: ["personality"] },
        { word: "anxious", categories: ["personality"] },
        { word: "appalling", categories: ["personality"] },
        { word: "appetizing", categories: ["taste"] },
        { word: "apprehensive", categories: ["personality"] },
        { word: "arrogant", categories: ["personality"] },
        { word: "ashamed", categories: ["personality"] },
        { word: "astonishing", categories: ["personality"] },
        { word: "attractive", categories: ["appearance"] },
        { word: "average", categories: ["appearance"] },
        { word: "bad", categories: ["condition"] },
        { word: "bald", categories: ["appearance"] },
        { word: "bashful", categories: ["personality"] },
        { word: "beautiful", categories: ["appearance"] },
        { word: "beefy", categories: ["appearance"] },
        { word: "belligerent", categories: ["personality"] },
        { word: "bent", categories: ["condition"] },
        { word: "better", categories: ["condition"] },
        { word: "best", categories: ["condition"] },
        { word: "better", categories: ["condition"] },
        { word: "bewildered", categories: ["personality"] },
        { word: "big", categories: ["size"] },
        { word: "billions", categories: ["quantity"] },
        { word: "billowy", categories: ["appearance"] },
        { word: "bitter", categories: ["taste"] },
        { word: "black", categories: ["color"] },
        { word: "bland", categories: ["taste"] },
        { word: "blue", categories: ["color"] },
        { word: "blushing", categories: ["appearance"] },
        { word: "bored", categories: ["personality"] },
        { word: "boring", categories: ["personality"] },
        { word: "boundless", categories: ["personality"] },
        { word: "brainy", categories: ["personality"] },
        { word: "brash", categories: ["personality"] },
        { word: "brave", categories: ["personality"] },
        { word: "breezy", categories: ["touch"] },
        { word: "brief", categories: ["time"] },
        { word: "bright", categories: ["appearance"] },
        { word: "broad", categories: ["shapes"] },
        { word: "broken", categories: ["condition"] },
        { word: "brown", categories: ["color"] },
        { word: "bulky", categories: ["appearance"] },
        { word: "bumpy", categories: ["touch"] },
        { word: "burly", categories: ["appearance"] },
        { word: "busy", categories: ["personality"] },
        { word: "cagey", categories: ["personality"] },
        { word: "calm", categories: ["personality"] },
        { word: "callous", categories: ["personality"] },
        { word: "careful", categories: ["condition"] },
        { word: "chilly", categories: ["touch"] },
        { word: "chubby", categories: ["appearance"] },
        { word: "clean", categories: ["appearance"] },
        { word: "clever", categories: ["condition"] },
        { word: "clumsy", categories: ["personality"] },
        { word: "cold", categories: ["touch"] },
        { word: "colossal", categories: ["size"] },
        { word: "cool", categories: ["touch"] },
        { word: "crashing", categories: ["sounds"] },
        { word: "creamy", categories: ["taste"] },
        { word: "crooked", categories: ["shapes"] },
        { word: "cuddly", categories: ["touch"] },
        { word: "curved", categories: ["shapes"] },
        { word: "damaged", categories: ["touch"] },
        { word: "damp", categories: ["touch"] },
        { word: "dazzling", categories: ["appearance"] },
        { word: "dead", categories: ["condition"] },
        { word: "deafening", categories: ["sounds"] },
        { word: "deep", categories: ["shapes"] },
        { word: "defeated", categories: ["personality"] },
        { word: "delicious", categories: ["taste"] },
        { word: "delightful", categories: ["personality"] },
        { word: "dirty", categories: ["touch"] },
        { word: "disgusting", categories: ["taste"] },
        { word: "drab", categories: ["appearance"] },
        { word: "dry", categories: ["touch"] },
        { word: "eager", categories: ["personality"] },
        { word: "early", categories: ["time"] },
        { word: "easy", categories: ["condition"] },
        { word: "echoing", categories: ["sounds"] },
        { word: "elegant", categories: ["appearance"] },
        { word: "embarrassed", categories: ["personality"] },
        { word: "enough", categories: ["quantity"] },
        { word: "faint", categories: ["sounds"] },
        { word: "faithful", categories: ["personality"] },
        { word: "famous", categories: ["condition"] },
        { word: "fancy", categories: ["appearance"] },
        { word: "fast", categories: ["time"] },
        { word: "fat", categories: ["size"] },
        { word: "few", categories: ["quantity"] },
        { word: "fierce", categories: ["personality"] },
        { word: "fit", categories: ["appearance"] },
        { word: "flabby", categories: ["appearance"] },
        { word: "flaky", categories: ["touch"] },
        { word: "flat", categories: ["shapes"] },
        { word: "fluffy", categories: ["touch"] },
        { word: "freezing", categories: ["touch"] },
        { word: "fresh", categories: ["taste"] },
        { word: "full", categories: ["quantity"] },
        { word: "future", categories: ["time"] },
        { word: "gentle", categories: ["personality"] },
        { word: "gifted", categories: ["condition"] },
        { word: "gigantic", categories: ["size"] },
        { word: "glamorous", categories: ["appearance"] },
        { word: "gorgeous", categories: ["appearance"] },
        { word: "gray", categories: ["color"] },
        { word: "greasy", categories: ["touch", "taste"] },
        { word: "great", categories: ["size"] },
        { word: "green", categories: ["color"] },
        { word: "grumpy", categories: ["personality"] },
        { word: "hallowed", categories: ["condition"] },
        { word: "handsome", categories: ["appearance"] },
        { word: "happy", categories: ["personality"] },
        { word: "harsh", categories: ["sounds"] },
        { word: "helpful", categories: ["condition"] },
        { word: "helpless", categories: ["personality"] },
        { word: "high", categories: ["shapes"] },
        { word: "hissing", categories: ["sounds"] },
        { word: "hollow", categories: ["shapes"] },
        { word: "hot", categories: ["touch", "taste"] },
        { word: "howling", categories: ["sounds"] },
        { word: "huge", categories: ["size"] },
        { word: "hundreds", categories: ["quantity"] },
        { word: "icy", categories: ["touch"] },
        { word: "immense", categories: ["size"] },
        { word: "important", categories: ["condition"] },
        { word: "incalculable", categories: ["quantity"] },
        { word: "inexpensive", categories: ["condition"] },
        { word: "itchy", categories: ["personality"] },
        { word: "jealous", categories: ["personality"] },
        { word: "jolly", categories: ["personality"] },
        { word: "juicy", categories: ["taste"] },
        { word: "kind", categories: ["personality"] },
        { word: "large", categories: ["size"] },
        { word: "late", categories: ["time"] },
        { word: "lazy", categories: ["personality"] },
        { word: "lemon", categories: ["color"] },
        { word: "limited", categories: ["quantity"] },
        { word: "little", categories: ["size", "quantity"] },
        { word: "lively", categories: ["personality"] },
        { word: "long", categories: ["time", "appearance"] },
        { word: "loose", categories: ["touch"] },
        { word: "loud", categories: ["sounds"] },
        { word: "low", categories: ["shapes"] },
        { word: "magnificent", categories: ["appearance"] },
        { word: "mammoth", categories: ["size"] },
        { word: "mango", categories: ["color"] },
        { word: "many", categories: ["quantity"] },
        { word: "massive", categories: ["size"] },
        { word: "mealy", categories: ["condition"] },
        { word: "melodic", categories: ["sounds"] },
        { word: "melted", categories: ["touch"] },
        { word: "microscopic", categories: ["size"] },
        { word: "millions", categories: ["quantity"] },
        { word: "miniature", categories: ["size"] },
        { word: "modern", categories: ["time"] },
        { word: "moldy", categories: ["taste"] },
        { word: "most", categories: ["quantity"] },
        { word: "muscular", categories: ["appearance"] },
        { word: "mushy", categories: ["condition"] },
        { word: "mysterious", categories: ["personality"] },
        { word: "narrow", categories: ["shapes"] },
        { word: "nervous", categories: ["personality"] },
        { word: "nice", categories: ["personality"] },
        { word: "noisy", categories: ["sounds"] },
        { word: "numerous", categories: ["quantity"] },
        { word: "nutritious", categories: ["taste"] },
        { word: "nutty", categories: ["taste"] },
        { word: "obedient", categories: ["personality"] },
        { word: "obnoxious", categories: ["personality"] },
        { word: "odd", categories: ["condition"] },
        { word: "old", categories: ["time"] },
        { word: "orange", categories: ["color"] },
        { word: "panicky", categories: ["personality"] },
        { word: "petite", categories: ["size"] },
        { word: "pitiful", categories: ["personality"] },
        { word: "plain", categories: ["appearance"] },
        { word: "plump", categories: ["appearance"] },
        { word: "polite", categories: ["personality"] },
        { word: "poor", categories: ["condition"] },
        { word: "powerful", categories: ["condition"] },
        { word: "prehistoric", categories: ["time"] },
        { word: "prickly", categories: ["touch"] },
        { word: "proud", categories: ["personality"] },
        { word: "puny", categories: ["size"] },
        { word: "purple", categories: ["color"] },
        { word: "purring", categories: ["sounds"] },
        { word: "putrid", categories: ["taste"] },
        { word: "quaint", categories: ["appearance"] },
        { word: "quick", categories: ["time"] },
        { word: "quiet", categories: ["sounds"] },
        { word: "rancid", categories: ["taste"] },
        { word: "rapid", categories: ["time"] },
        { word: "rapping", categories: ["sounds"] },
        { word: "raspy", categories: ["sounds"] },
        { word: "red", categories: ["color"] },
        { word: "refined", categories: ["shapes"] },
        { word: "repulsive", categories: ["personality"] },
        { word: "rhythmic", categories: ["sounds"] },
        { word: "rich", categories: ["condition"] },
        { word: "ripe", categories: ["taste"] },
        { word: "rotten", categories: ["taste"] },
        { word: "rough", categories: ["touch"] },
        { word: "round", categories: ["shapes"] },
        { word: "salmon", categories: ["color"] },
        { word: "salty", categories: ["taste"] },
        { word: "savory", categories: ["taste"] },
        { word: "scarce", categories: ["quantity"] },
        { word: "scary", categories: ["personality"] },
        { word: "scrawny", categories: ["size"] },
        { word: "screeching", categories: ["sounds"] },
        { word: "scruffy", categories: ["appearance"] },
        { word: "shaggy", categories: ["touch"] },
        { word: "shallow", categories: ["shapes"] },
        { word: "shapely", categories: ["appearance"] },
        { word: "sharp", categories: ["touch"] },
        { word: "short", categories: ["size", "appearance", "time"] },
        { word: "shrilling", categories: ["sounds"] },
        { word: "shy", categories: ["condition"] },
        { word: "silly", categories: ["personality"] },
        { word: "skinny", categories: ["appearance", "shapes"] },
        { word: "slimy", categories: ["touch"] },
        { word: "slow", categories: ["time"] },
        { word: "small", categories: ["size"] },
        { word: "some", categories: ["quantity"] },
        { word: "sour", categories: ["taste"] },
        { word: "sparse", categories: ["quantity"] },
        { word: "spicy", categories: ["taste"] },
        { word: "spoiled", categories: ["taste"] },
        { word: "square", categories: ["shapes"] },
        { word: "squeaking", categories: ["sounds"] },
        { word: "stale", categories: ["taste"] },
        { word: "steep", categories: ["shapes"] },
        { word: "sticky", categories: ["touch"] },
        { word: "stocky", categories: ["appearance"] },
        { word: "straight", categories: ["shapes"] },
        { word: "strong", categories: ["touch"] },
        { word: "substantial", categories: ["quantity"] },
        { word: "sweet", categories: ["taste"] },
        { word: "swift", categories: ["time"] },
        { word: "tall", categories: ["size"] },
        { word: "tangy", categories: ["taste"] },
        { word: "tart", categories: ["taste"] },
        { word: "tasteless", categories: ["taste"] },
        { word: "tasty", categories: ["taste"] },
        { word: "teeny", categories: ["size"] },
        { word: "tender", categories: ["condition"] },
        { word: "thankful", categories: ["personality"] },
        { word: "thoughtless", categories: ["personality"] },
        { word: "thousands", categories: ["quantity"] },
        { word: "thundering", categories: ["sounds"] },
        { word: "tight", categories: ["touch"] },
        { word: "tinkling", categories: ["sounds"] },
        { word: "tiny", categories: ["size"] },
        { word: "ugly", categories: ["appearance"] },
        { word: "uneven", categories: ["touch"] },
        { word: "unimportant", categories: ["condition"] },
        { word: "uninterested", categories: ["condition"] },
        { word: "unkempt", categories: ["appearance"] },
        { word: "unsightly", categories: ["appearance"] },
        { word: "uptight", categories: ["personality"] },
        { word: "vast", categories: ["condition"] },
        { word: "victorious", categories: ["personality"] },
        { word: "wailing", categories: ["sounds"] },
        { word: "warm", categories: ["touch"] },
        { word: "weak", categories: ["touch"] },
        { word: "wet", categories: ["touch"] },
        { word: "whining", categories: ["sounds"] },
        { word: "whispering", categories: ["sounds"] },
        { word: "white", categories: ["color"] },
        { word: "wide", categories: ["shapes"] },
        { word: "witty", categories: ["personality"] },
        { word: "wonderful", categories: ["personality"] },
        { word: "wooden", categories: ["touch"] },
        { word: "worried", categories: ["personality"] },
        { word: "wrong", categories: ["condition"] },
        { word: "yellow", categories: ["color"] },
        { word: "young", categories: ["time"] },
        { word: "yummy", categories: ["taste"] },
        { word: "zealous", categories: ["personality"] }
      ]
    };
    function getWordsByCategory(partOfSpeech, categories) {
      var e_1, _a;
      if (categories === void 0) {
        categories = [];
      }
      var selectedCategoried = new Set(categories);
      var selectedWords = [];
      try {
        for (var _b = __values(exports.wordList[partOfSpeech]), _c = _b.next(); !_c.done; _c = _b.next()) {
          var word = _c.value;
          if (categories.length === 0 || word.categories.some(function(cat) {
            return selectedCategoried.has(cat);
          })) {
            selectedWords.push(word.word);
          }
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (_c && !_c.done && (_a = _b.return))
            _a.call(_b);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
      return selectedWords;
    }
    exports.getWordsByCategory = getWordsByCategory;
  }
});

// node_modules/random-word-slugs/dist/index.js
var require_dist = __commonJS({
  "node_modules/random-word-slugs/dist/index.js"(exports) {
    "use strict";
    var __assign = exports && exports.__assign || function() {
      __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.totalUniqueSlugs = exports.generateSlug = void 0;
    var words_1 = require_words();
    var DEFAULT_NUMBER_OF_WORDS = 3;
    function generateSlug4(numberOfWords, options) {
      var numWords = numberOfWords || DEFAULT_NUMBER_OF_WORDS;
      var defaultOptions = {
        partsOfSpeech: getDefaultPartsOfSpeech(numWords),
        categories: {},
        format: "kebab"
      };
      var opts = __assign(__assign({}, defaultOptions), options);
      var words = [];
      for (var i = 0; i < numWords; i++) {
        var partOfSpeech = opts.partsOfSpeech[i];
        var candidates = words_1.getWordsByCategory(opts.partsOfSpeech[i], opts.categories[partOfSpeech]);
        var rand = candidates[Math.floor(Math.random() * candidates.length)];
        words.push(rand);
      }
      return formatter(words, opts.format);
    }
    exports.generateSlug = generateSlug4;
    function getDefaultPartsOfSpeech(length) {
      var partsOfSpeech = [];
      for (var i = 0; i < length - 1; i++) {
        partsOfSpeech.push("adjective");
      }
      partsOfSpeech.push("noun");
      return partsOfSpeech;
    }
    function formatter(arr, format) {
      if (format === "kebab") {
        return arr.join("-").toLowerCase();
      }
      if (format === "camel") {
        return arr.map(function(el, i) {
          if (i === 0)
            return el.toLowerCase();
          return el[0].toUpperCase() + el.slice(1).toLowerCase();
        }).join("");
      }
      if (format === "lower") {
        return arr.join(" ").toLowerCase();
      }
      if (format === "sentence") {
        return arr.map(function(el, i) {
          if (i === 0) {
            return el[0].toUpperCase() + el.slice(1).toLowerCase();
          }
          return el;
        }).join(" ");
      }
      return arr.map(function(el) {
        return el[0].toUpperCase() + el.slice(1).toLowerCase();
      }).join(" ");
    }
    function totalUniqueSlugs(numberOfWords, options) {
      var _a, _b;
      var numAdjectives = words_1.getWordsByCategory("adjective", (_a = options === null || options === void 0 ? void 0 : options.categories) === null || _a === void 0 ? void 0 : _a.adjective).length;
      var numNouns = words_1.getWordsByCategory("noun", (_b = options === null || options === void 0 ? void 0 : options.categories) === null || _b === void 0 ? void 0 : _b.noun).length;
      var nums = {
        adjective: numAdjectives,
        noun: numNouns
      };
      var numWords = numberOfWords || DEFAULT_NUMBER_OF_WORDS;
      var partsOfSpeech = (options === null || options === void 0 ? void 0 : options.partsOfSpeech) || getDefaultPartsOfSpeech(numWords);
      var combos = 1;
      for (var i = 0; i < numWords; i++) {
        combos *= nums[partsOfSpeech[i]];
      }
      return combos;
    }
    exports.totalUniqueSlugs = totalUniqueSlugs;
  }
});

// node_modules/randomcolor/randomColor.js
var require_randomColor = __commonJS({
  "node_modules/randomcolor/randomColor.js"(exports, module2) {
    (function(root, factory) {
      if (typeof exports === "object") {
        var randomColor2 = factory();
        if (typeof module2 === "object" && module2 && module2.exports) {
          exports = module2.exports = randomColor2;
        }
        exports.randomColor = randomColor2;
      } else if (typeof define === "function" && define.amd) {
        define([], factory);
      } else {
        root.randomColor = factory();
      }
    })(exports, function() {
      var seed = null;
      var colorDictionary = {};
      loadColorBounds();
      var colorRanges = [];
      var randomColor2 = function(options) {
        options = options || {};
        if (options.seed !== void 0 && options.seed !== null && options.seed === parseInt(options.seed, 10)) {
          seed = options.seed;
        } else if (typeof options.seed === "string") {
          seed = stringToInteger(options.seed);
        } else if (options.seed !== void 0 && options.seed !== null) {
          throw new TypeError("The seed value must be an integer or string");
        } else {
          seed = null;
        }
        var H, S, B;
        if (options.count !== null && options.count !== void 0) {
          var totalColors = options.count, colors = [];
          for (var i = 0; i < options.count; i++) {
            colorRanges.push(false);
          }
          options.count = null;
          while (totalColors > colors.length) {
            var color = randomColor2(options);
            if (seed !== null) {
              options.seed = seed;
            }
            colors.push(color);
          }
          options.count = totalColors;
          return colors;
        }
        H = pickHue(options);
        S = pickSaturation(H, options);
        B = pickBrightness(H, S, options);
        return setFormat([H, S, B], options);
      };
      function pickHue(options) {
        if (colorRanges.length > 0) {
          var hueRange = getRealHueRange(options.hue);
          var hue = randomWithin(hueRange);
          var step = (hueRange[1] - hueRange[0]) / colorRanges.length;
          var j = parseInt((hue - hueRange[0]) / step);
          if (colorRanges[j] === true) {
            j = (j + 2) % colorRanges.length;
          } else {
            colorRanges[j] = true;
          }
          var min = (hueRange[0] + j * step) % 359, max = (hueRange[0] + (j + 1) * step) % 359;
          hueRange = [min, max];
          hue = randomWithin(hueRange);
          if (hue < 0) {
            hue = 360 + hue;
          }
          return hue;
        } else {
          var hueRange = getHueRange(options.hue);
          hue = randomWithin(hueRange);
          if (hue < 0) {
            hue = 360 + hue;
          }
          return hue;
        }
      }
      function pickSaturation(hue, options) {
        if (options.hue === "monochrome") {
          return 0;
        }
        if (options.luminosity === "random") {
          return randomWithin([0, 100]);
        }
        var saturationRange = getSaturationRange(hue);
        var sMin = saturationRange[0], sMax = saturationRange[1];
        switch (options.luminosity) {
          case "bright":
            sMin = 55;
            break;
          case "dark":
            sMin = sMax - 10;
            break;
          case "light":
            sMax = 55;
            break;
        }
        return randomWithin([sMin, sMax]);
      }
      function pickBrightness(H, S, options) {
        var bMin = getMinimumBrightness(H, S), bMax = 100;
        switch (options.luminosity) {
          case "dark":
            bMax = bMin + 20;
            break;
          case "light":
            bMin = (bMax + bMin) / 2;
            break;
          case "random":
            bMin = 0;
            bMax = 100;
            break;
        }
        return randomWithin([bMin, bMax]);
      }
      function setFormat(hsv, options) {
        switch (options.format) {
          case "hsvArray":
            return hsv;
          case "hslArray":
            return HSVtoHSL(hsv);
          case "hsl":
            var hsl = HSVtoHSL(hsv);
            return "hsl(" + hsl[0] + ", " + hsl[1] + "%, " + hsl[2] + "%)";
          case "hsla":
            var hslColor = HSVtoHSL(hsv);
            var alpha = options.alpha || Math.random();
            return "hsla(" + hslColor[0] + ", " + hslColor[1] + "%, " + hslColor[2] + "%, " + alpha + ")";
          case "rgbArray":
            return HSVtoRGB(hsv);
          case "rgb":
            var rgb = HSVtoRGB(hsv);
            return "rgb(" + rgb.join(", ") + ")";
          case "rgba":
            var rgbColor = HSVtoRGB(hsv);
            var alpha = options.alpha || Math.random();
            return "rgba(" + rgbColor.join(", ") + ", " + alpha + ")";
          default:
            return HSVtoHex(hsv);
        }
      }
      function getMinimumBrightness(H, S) {
        var lowerBounds = getColorInfo(H).lowerBounds;
        for (var i = 0; i < lowerBounds.length - 1; i++) {
          var s1 = lowerBounds[i][0], v1 = lowerBounds[i][1];
          var s2 = lowerBounds[i + 1][0], v2 = lowerBounds[i + 1][1];
          if (S >= s1 && S <= s2) {
            var m = (v2 - v1) / (s2 - s1), b = v1 - m * s1;
            return m * S + b;
          }
        }
        return 0;
      }
      function getHueRange(colorInput) {
        if (typeof parseInt(colorInput) === "number") {
          var number = parseInt(colorInput);
          if (number < 360 && number > 0) {
            return [number, number];
          }
        }
        if (typeof colorInput === "string") {
          if (colorDictionary[colorInput]) {
            var color = colorDictionary[colorInput];
            if (color.hueRange) {
              return color.hueRange;
            }
          } else if (colorInput.match(/^#?([0-9A-F]{3}|[0-9A-F]{6})$/i)) {
            var hue = HexToHSB(colorInput)[0];
            return [hue, hue];
          }
        }
        return [0, 360];
      }
      function getSaturationRange(hue) {
        return getColorInfo(hue).saturationRange;
      }
      function getColorInfo(hue) {
        if (hue >= 334 && hue <= 360) {
          hue -= 360;
        }
        for (var colorName in colorDictionary) {
          var color = colorDictionary[colorName];
          if (color.hueRange && hue >= color.hueRange[0] && hue <= color.hueRange[1]) {
            return colorDictionary[colorName];
          }
        }
        return "Color not found";
      }
      function randomWithin(range) {
        if (seed === null) {
          var golden_ratio = 0.618033988749895;
          var r = Math.random();
          r += golden_ratio;
          r %= 1;
          return Math.floor(range[0] + r * (range[1] + 1 - range[0]));
        } else {
          var max = range[1] || 1;
          var min = range[0] || 0;
          seed = (seed * 9301 + 49297) % 233280;
          var rnd = seed / 233280;
          return Math.floor(min + rnd * (max - min));
        }
      }
      function HSVtoHex(hsv) {
        var rgb = HSVtoRGB(hsv);
        function componentToHex(c) {
          var hex2 = c.toString(16);
          return hex2.length == 1 ? "0" + hex2 : hex2;
        }
        var hex = "#" + componentToHex(rgb[0]) + componentToHex(rgb[1]) + componentToHex(rgb[2]);
        return hex;
      }
      function defineColor(name, hueRange, lowerBounds) {
        var sMin = lowerBounds[0][0], sMax = lowerBounds[lowerBounds.length - 1][0], bMin = lowerBounds[lowerBounds.length - 1][1], bMax = lowerBounds[0][1];
        colorDictionary[name] = {
          hueRange,
          lowerBounds,
          saturationRange: [sMin, sMax],
          brightnessRange: [bMin, bMax]
        };
      }
      function loadColorBounds() {
        defineColor("monochrome", null, [[0, 0], [100, 0]]);
        defineColor("red", [-26, 18], [[20, 100], [30, 92], [40, 89], [50, 85], [60, 78], [70, 70], [80, 60], [90, 55], [100, 50]]);
        defineColor("orange", [18, 46], [[20, 100], [30, 93], [40, 88], [50, 86], [60, 85], [70, 70], [100, 70]]);
        defineColor("yellow", [46, 62], [[25, 100], [40, 94], [50, 89], [60, 86], [70, 84], [80, 82], [90, 80], [100, 75]]);
        defineColor("green", [62, 178], [[30, 100], [40, 90], [50, 85], [60, 81], [70, 74], [80, 64], [90, 50], [100, 40]]);
        defineColor("blue", [178, 257], [[20, 100], [30, 86], [40, 80], [50, 74], [60, 60], [70, 52], [80, 44], [90, 39], [100, 35]]);
        defineColor("purple", [257, 282], [[20, 100], [30, 87], [40, 79], [50, 70], [60, 65], [70, 59], [80, 52], [90, 45], [100, 42]]);
        defineColor("pink", [282, 334], [[20, 100], [30, 90], [40, 86], [60, 84], [80, 80], [90, 75], [100, 73]]);
      }
      function HSVtoRGB(hsv) {
        var h = hsv[0];
        if (h === 0) {
          h = 1;
        }
        if (h === 360) {
          h = 359;
        }
        h = h / 360;
        var s = hsv[1] / 100, v = hsv[2] / 100;
        var h_i = Math.floor(h * 6), f = h * 6 - h_i, p = v * (1 - s), q = v * (1 - f * s), t = v * (1 - (1 - f) * s), r = 256, g = 256, b = 256;
        switch (h_i) {
          case 0:
            r = v;
            g = t;
            b = p;
            break;
          case 1:
            r = q;
            g = v;
            b = p;
            break;
          case 2:
            r = p;
            g = v;
            b = t;
            break;
          case 3:
            r = p;
            g = q;
            b = v;
            break;
          case 4:
            r = t;
            g = p;
            b = v;
            break;
          case 5:
            r = v;
            g = p;
            b = q;
            break;
        }
        var result = [Math.floor(r * 255), Math.floor(g * 255), Math.floor(b * 255)];
        return result;
      }
      function HexToHSB(hex) {
        hex = hex.replace(/^#/, "");
        hex = hex.length === 3 ? hex.replace(/(.)/g, "$1$1") : hex;
        var red = parseInt(hex.substr(0, 2), 16) / 255, green = parseInt(hex.substr(2, 2), 16) / 255, blue = parseInt(hex.substr(4, 2), 16) / 255;
        var cMax = Math.max(red, green, blue), delta = cMax - Math.min(red, green, blue), saturation = cMax ? delta / cMax : 0;
        switch (cMax) {
          case red:
            return [60 * ((green - blue) / delta % 6) || 0, saturation, cMax];
          case green:
            return [60 * ((blue - red) / delta + 2) || 0, saturation, cMax];
          case blue:
            return [60 * ((red - green) / delta + 4) || 0, saturation, cMax];
        }
      }
      function HSVtoHSL(hsv) {
        var h = hsv[0], s = hsv[1] / 100, v = hsv[2] / 100, k = (2 - s) * v;
        return [
          h,
          Math.round(s * v / (k < 1 ? k : 2 - k) * 1e4) / 100,
          k / 2 * 100
        ];
      }
      function stringToInteger(string) {
        var total = 0;
        for (var i = 0; i !== string.length; i++) {
          if (total >= Number.MAX_SAFE_INTEGER)
            break;
          total += string.charCodeAt(i);
        }
        return total;
      }
      function getRealHueRange(colorHue) {
        if (!isNaN(colorHue)) {
          var number = parseInt(colorHue);
          if (number < 360 && number > 0) {
            return getColorInfo(colorHue).hueRange;
          }
        } else if (typeof colorHue === "string") {
          if (colorDictionary[colorHue]) {
            var color = colorDictionary[colorHue];
            if (color.hueRange) {
              return color.hueRange;
            }
          } else if (colorHue.match(/^#?([0-9A-F]{3}|[0-9A-F]{6})$/i)) {
            var hue = HexToHSB(colorHue)[0];
            return getColorInfo(hue).hueRange;
          }
        }
        return [0, 360];
      }
      return randomColor2;
    });
  }
});

// src/main.ts
__export(exports, {
  default: () => main_default
});

// src/snippetor-Plugin.ts
var import_obsidian4 = __toModule(require("obsidian"));

// src/snippetor-Defaults.ts
var MAGIC_WAND = '<svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="magic" class="svg-inline--fa fa-magic fa-w-16" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentColor" d="M224 96l16-32 32-16-32-16-16-32-16 32-32 16 32 16 16 32zM80 160l26.66-53.33L160 80l-53.34-26.67L80 0 53.34 53.33 0 80l53.34 26.67L80 160zm352 128l-26.66 53.33L352 368l53.34 26.67L432 448l26.66-53.33L512 368l-53.34-26.67L432 288zm70.62-193.77L417.77 9.38C411.53 3.12 403.34 0 395.15 0c-8.19 0-16.38 3.12-22.63 9.38L9.38 372.52c-12.5 12.5-12.5 32.76 0 45.25l84.85 84.85c6.25 6.25 14.44 9.37 22.62 9.37 8.19 0 16.38-3.12 22.63-9.37l363.14-363.15c12.5-12.48 12.5-32.75 0-45.24zM359.45 203.46l-50.91-50.91 86.6-86.6 50.91 50.91-86.6 86.6z"></path></svg>';
var MAKE_IT_SO = "snippetor-gen";
var DEFAULT_SETTINGS = {
  snippets: {}
};
var DEFAULT_TASK_SNIPPET_SETTINGS = {
  name: "",
  type: "simple-task",
  clearThemeBackground: false,
  taskSettings: []
};

// src/snippetor-SettingsTab.ts
var import_obsidian2 = __toModule(require("obsidian"));
var import_random_word_slugs2 = __toModule(require_dist());

// src/snippetor-CreateCheckboxesModal.ts
var import_obsidian = __toModule(require("obsidian"));
var import_random_word_slugs = __toModule(require_dist());
function openCreateCheckboxModal(app, taskSnippetCfg, snippetor) {
  return new Promise((resolve2) => {
    const modal = new CreateCheckboxesModal(app, taskSnippetCfg, snippetor);
    modal.onClose = () => {
      if (!modal.cfg.name) {
        modal.cfg.name = (0, import_random_word_slugs.generateSlug)(2);
      }
      resolve2(modal.cfg);
    };
    modal.open();
  });
}
var CreateCheckboxesModal = class extends import_obsidian.Modal {
  constructor(app, taskSnippetCfg, snippetor) {
    super(app);
    this.snippetor = snippetor;
    this.containerEl.id = "snippetor-checkboxes-modal";
    this.cfg = taskSnippetCfg || snippetor.createNewTaskSnippetCfg();
    this.cfg.taskSettings.forEach((t) => {
      if (t.taskColorDark && !t.taskColorLight) {
        t.taskColorLight = t.taskColorDark;
      } else if (t.taskColorLight && !t.taskColorDark) {
        t.taskColorDark = t.taskColorLight;
      }
    });
    this.orig = this.cfg;
    this.id = 0;
    this.elements = {
      tasks: [],
      items: [],
      data: []
    };
  }
  get snapshot() {
    return this.orig;
  }
  onOpen() {
    this.titleEl.createSpan({ text: "Snippetor: Tasks" });
    const content = this.contentEl.createDiv("snippetor-checkboxes markdown-preview-view");
    new import_obsidian.Setting(content).setName("Name of generated snippet (filename)").addText((text) => {
      text.setPlaceholder("trigger").setValue(this.cfg.name).onChange((value) => {
        this.cfg.name = value;
      });
    }).addButton((button) => button.setIcon(MAKE_IT_SO).setClass("generate-css").setTooltip("Generate CSS Snippet").onClick(() => __async(this, null, function* () {
      button.buttonEl.addClass("is-active");
      button.disabled = true;
      yield this.snippetor.generateCss(this.cfg);
      button.buttonEl.removeClass("is-active");
      button.disabled = false;
    })));
    const h3 = content.createEl("h3", {
      cls: "snippetor-reset",
      text: "Custom Task Values"
    });
    const reset = h3.createSpan("setting-item-control");
    new import_obsidian.ButtonComponent(reset).setIcon("reset").onClick(() => {
      this.cfg = JSON.parse(JSON.stringify(this.snapshot));
      this.showTaskRows();
    });
    this.elements.list = content.createEl("ul");
    this.showTaskRows();
    new import_obsidian.Setting(content).setClass("snippetor-create-task").addButton((button) => button.setTooltip("Add a task type").setButtonText("+").onClick(() => {
      const taskSettings = this.snippetor.createNewTaskCfg("");
      this.createTaskRow(taskSettings);
      this.cfg.taskSettings.push(taskSettings);
    }));
    content.createEl("h3", {
      text: "Additional settings"
    });
    new import_obsidian.Setting(content).setName("Suppress theme-defined background color").setDesc("Does theme styling show around your selected tasks? Your theme may provide a way to disable task styling (preferred). This might also work.").addToggle((t) => {
      t.setValue(this.cfg.clearThemeBackground).onChange((v) => {
        this.cfg.clearThemeBackground = v;
        this.elements.tasks.forEach((t2) => this.applyCommonSettingsToCheckbox(t2));
      });
    });
  }
  onClose() {
    this.contentEl.empty();
  }
  showTaskRows() {
    this.elements.tasks.length = 0;
    this.elements.items.length = 0;
    this.elements.data.length = 0;
    this.elements.list.empty();
    this.createHeaderRow(() => this.showTaskRows());
    this.cfg.taskSettings.forEach((ts) => {
      this.createTaskRow(ts);
    });
  }
  createHeaderRow(callback) {
    const heading = this.elements.list.createEl("li", {
      cls: "task-list-item"
    });
    const preview = heading.createSpan("snippetor-preview");
    preview.createEl("input", {
      cls: "task-list-item-checkbox",
      attr: {
        type: "checkbox"
      }
    });
    preview.createSpan({
      text: "Preview",
      cls: "example snippetor-heading"
    });
    heading.createSpan({
      text: "Settings",
      cls: "snippetor-settings snippetor-heading"
    });
    new import_obsidian.ToggleComponent(heading).setValue(this.isLightMode()).onChange((value) => __async(this, null, function* () {
      if (value) {
        this.containerEl.addClass("theme-light");
        this.containerEl.removeClass("theme-dark");
      } else {
        this.containerEl.addClass("theme-dark");
        this.containerEl.removeClass("theme-light");
      }
      return callback();
    })).toggleEl.addClass("theme-toggle");
  }
  createTaskRow(taskSettings) {
    const li = this.elements.list.createEl("li");
    this.applySettingsToListItem(taskSettings, li);
    this.elements.items.push(li);
    const preview = li.createSpan("snippetor-preview");
    const checkbox = preview.createEl("input", {
      cls: "task-list-item-checkbox",
      attr: {
        type: "checkbox"
      }
    });
    this.applySettingsToCheckbox(taskSettings, checkbox);
    this.applyCommonSettingsToCheckbox(checkbox);
    this.elements.tasks.push(checkbox);
    preview.createSpan({ text: "example", cls: "example" });
    const settings = li.createSpan("snippetor-settings");
    this.showBasicSettings(taskSettings, li, checkbox, settings);
    new import_obsidian.ButtonComponent(li).setIcon("trash").setTooltip("Delete this Task").onClick(() => __async(this, null, function* () {
      console.log("Delete %o", li);
      this.cfg.taskSettings.remove(taskSettings);
      this.showTaskRows();
    }));
  }
  showBasicSettings(taskSettings, li, checkbox, settings) {
    const i = this.id++;
    const dataTask = settings.createEl("input", {
      cls: "snippetor-data-task",
      attr: {
        type: "text",
        name: "task-" + i,
        size: "1",
        value: taskSettings.data,
        title: "Task value"
      }
    });
    this.elements.data.push(dataTask);
    this.verifyDataValue(dataTask);
    dataTask.addEventListener("input", () => {
      taskSettings.data = dataTask.value;
      this.applySettingsToListItem(taskSettings, li);
      this.applySettingsToCheckbox(taskSettings, checkbox);
      this.verifyDataValue(dataTask);
    }, false);
    const taskColor = settings.createEl("input", {
      cls: "snippetor-data-color",
      attr: {
        name: "color-" + i,
        type: "color",
        value: this.getThemeColor(taskSettings),
        title: "Foreground color for the task"
      }
    });
    taskColor.addEventListener("input", () => {
      this.setThemeColor(taskSettings, taskColor.value);
      this.applyColor(taskSettings, li, checkbox);
    }, false);
    const colorSync = settings.createSpan({
      text: "\u{1F317}",
      attr: {
        name: "color-sync-" + i,
        "aria-label": `Copy value from ${this.isLightMode() ? "dark" : "light"} mode`,
        style: "cursor: pointer"
      }
    });
    colorSync.addEventListener("click", () => {
      if (this.isLightMode()) {
        taskColor.value = taskSettings.taskColorDark;
      } else {
        taskColor.value = taskSettings.taskColorLight;
      }
      this.setThemeColor(taskSettings, taskColor.value);
      this.applyColor(taskSettings, li, checkbox);
    }, false);
    const colorText = settings.createEl("input", {
      attr: {
        name: "text-color-" + i,
        type: "checkbox",
        value: taskSettings.applyTextColor
      }
    });
    if (taskSettings.applyTextColor) {
      colorText.setAttribute("checked", "");
    }
    colorText.addEventListener("click", () => {
      taskSettings.applyTextColor = colorText.checked;
      this.applyColor(taskSettings, li, checkbox);
    }, false);
    settings.createEl("label", {
      text: "apply color to text",
      attr: { for: "text-color-" + i }
    });
    const strikethrough = settings.createEl("input", {
      attr: {
        name: "strikethrough-" + i,
        type: "checkbox"
      }
    });
    if (taskSettings.strkethrough) {
      strikethrough.setAttribute("checked", "");
    }
    strikethrough.addEventListener("click", () => {
      taskSettings.strkethrough = strikethrough.checked;
      this.applySettingsToListItem(taskSettings, li);
    }, false);
    settings.createEl("label", {
      text: "strikethrough",
      attr: { for: "strikethrough-" + i }
    });
  }
  applyColor(taskSettings, li, checkbox) {
    this.applySettingsToCheckbox(taskSettings, checkbox);
    this.applySettingsToListItem(taskSettings, li);
  }
  applySettingsToListItem(taskSettings, li) {
    li.setAttr("data-task", taskSettings.data);
    li.className = "task-list-item" + (taskSettings.data == " " ? "" : " is-checked");
    if (taskSettings.strkethrough) {
      li.style.textDecoration = "line-through";
    } else {
      li.style.textDecoration = "none";
    }
    if (taskSettings.applyTextColor) {
      this.setColor(taskSettings, li);
    } else {
      li.style.removeProperty("color");
    }
  }
  applySettingsToCheckbox(taskSettings, checkbox) {
    if (taskSettings.data !== " ") {
      checkbox.setAttribute("checked", "");
      checkbox.setAttribute("data", taskSettings.data);
    } else {
      checkbox.removeAttribute("data");
    }
    this.setColorAttributes(taskSettings, checkbox);
  }
  applyCommonSettingsToCheckbox(checkbox) {
    checkbox.style.removeProperty("background-color");
    if (this.cfg.clearThemeBackground) {
      const style = checkbox.getAttribute("style");
      checkbox.setAttribute("style", style + " background-color: unset !important;");
    }
  }
  isLightMode() {
    return this.containerEl.hasClass("theme-light") || !this.containerEl.hasClass("theme-dark") && document.body.hasClass("theme-light");
  }
  getThemeColor(taskSettings) {
    if (this.isLightMode()) {
      return taskSettings.taskColorLight;
    } else {
      return taskSettings.taskColorDark;
    }
  }
  setThemeColor(taskSettings, color) {
    if (this.isLightMode()) {
      taskSettings.taskColorLight = color;
    } else {
      taskSettings.taskColorDark = color;
    }
  }
  setColor(taskSettings, element) {
    const taskColor = this.getThemeColor(taskSettings);
    if (taskColor && taskColor.length > 0) {
      element.style.color = taskColor;
    } else {
      element.style.removeProperty("color");
    }
  }
  setColorAttributes(taskSettings, element) {
    const taskColor = this.getThemeColor(taskSettings);
    if (taskColor && taskColor.length > 0) {
      element.style.borderColor = taskColor;
      element.style.color = taskColor;
      element.setAttribute("color", taskColor);
    } else {
      element.style.removeProperty("border-color");
      element.style.removeProperty("color");
      element.removeAttribute("color");
    }
  }
  verifyDataValue(input) {
    if (this.cfg.taskSettings.filter((t) => input.value === t.data).length > 1) {
      input.style.borderColor = "var(--background-modifier-error)";
      input.setAttribute("aria-label", "Another task uses the same value");
      input.setAttribute("conflict", input.value);
      this.elements.data.forEach((e) => {
        if (e.value === input.value && !e.hasAttribute("conflict")) {
          this.verifyDataValue(e);
        }
      });
    } else {
      input.style.removeProperty("border-color");
      input.removeAttribute("aria-label");
      const conflict = input.getAttribute("conflict");
      if (conflict) {
        input.removeAttribute("conflict");
        this.elements.data.forEach((e) => {
          if (e.value === conflict) {
            this.verifyDataValue(e);
          }
        });
      }
    }
  }
};

// src/snippetor-SettingsTab.ts
var SnippetorSettingsTab = class extends import_obsidian2.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    this.containerEl.empty();
    this.containerEl.addClass("snippetor-plugin-settings");
    this.containerEl.createEl("h2", { text: "Snippetor" });
    this.buildNewSnippet();
    this.existingEl = this.containerEl.createDiv();
    this.listExistingSnippets();
    const div = this.containerEl.createDiv("coffee");
    const fgColor = this.isLightMode() ? "666" : "AAA";
    const bgColor = this.isLightMode() ? "D8C9D5" : "684B62";
    div.createEl("a", {
      href: "https://www.buymeacoffee.com/ebullient"
    }).createEl("img", {
      attr: {
        src: `https://img.buymeacoffee.com/button-api/?text=Buy me a coffee&emoji=&slug=ebullient&button_colour=${bgColor}&font_colour=${fgColor}&font_family=Inter&outline_colour=${fgColor}&coffee_colour=FFDD00`
      }
    });
  }
  buildNewSnippet() {
    const selector = {
      type: DEFAULT_TASK_SNIPPET_SETTINGS.type
    };
    new import_obsidian2.Setting(this.containerEl).setClass("snippetor-create-snippet").setName("Create a new CSS snippet (select type)").addDropdown((d) => {
      d.addOption(DEFAULT_TASK_SNIPPET_SETTINGS.type, "Custom checkboxes");
      d.setValue(DEFAULT_TASK_SNIPPET_SETTINGS.type);
      d.onChange((v) => {
        selector.type = v;
      });
    }).addButton((button) => button.setTooltip("Create a Snippet").setButtonText("+").onClick(() => __async(this, null, function* () {
      yield this.openModal(selector.type, null);
    })));
  }
  listExistingSnippets() {
    this.existingEl.empty();
    for (const snippet of this.plugin.allSnippets) {
      console.log(snippet);
      new import_obsidian2.Setting(this.existingEl).setName(snippet.name).setDesc(this.getDescription(snippet.type)).addButton((b) => b.setIcon("pencil").setTooltip("Edit this Snippet").onClick(() => __async(this, null, function* () {
        yield this.openModal(snippet.type, snippet);
      }))).addButton((b) => b.setIcon("duplicate-glyph").setTooltip("Copy this Snippet").onClick(() => __async(this, null, function* () {
        const copy = JSON.parse(JSON.stringify(snippet));
        copy.name = (0, import_random_word_slugs2.generateSlug)(2);
        new import_obsidian2.Notice(`Copied snippet '${snippet.name}' to '${copy.name}'`);
        yield this.openModal(snippet.type, copy);
      }))).addButton((b) => b.setIcon("trash").setTooltip("Delete this Snippet").onClick(() => __async(this, null, function* () {
        yield this.plugin.removeSnippet(snippet);
        this.listExistingSnippets();
      })));
    }
  }
  getDescription(type) {
    return "simple checkboxes";
  }
  openModal(type, snippet) {
    return __async(this, null, function* () {
      if (type === DEFAULT_TASK_SNIPPET_SETTINGS.type) {
        const taskCfg = yield openCreateCheckboxModal(this.app, snippet, this.plugin.snippetor);
        console.debug("Snippetor: modal closed with %o", taskCfg);
        yield this.plugin.setSnippet(taskCfg);
        this.listExistingSnippets();
      }
    });
  }
  isLightMode() {
    return document.body.hasClass("theme-light");
  }
};

// src/snippetor-Snippetor.ts
var import_obsidian3 = __toModule(require("obsidian"));

// node_modules/eta/dist/eta.es.js
var import_fs = __toModule(require("fs"));
var import_path = __toModule(require("path"));
function setPrototypeOf(obj, proto) {
  if (Object.setPrototypeOf) {
    Object.setPrototypeOf(obj, proto);
  } else {
    obj.__proto__ = proto;
  }
}
function EtaErr(message) {
  var err = new Error(message);
  setPrototypeOf(err, EtaErr.prototype);
  return err;
}
EtaErr.prototype = Object.create(Error.prototype, {
  name: { value: "Eta Error", enumerable: false }
});
function ParseErr(message, str, indx) {
  var whitespace = str.slice(0, indx).split(/\n/);
  var lineNo = whitespace.length;
  var colNo = whitespace[lineNo - 1].length + 1;
  message += " at line " + lineNo + " col " + colNo + ":\n\n  " + str.split(/\n/)[lineNo - 1] + "\n  " + Array(colNo).join(" ") + "^";
  throw EtaErr(message);
}
var promiseImpl = new Function("return this")().Promise;
function getAsyncFunctionConstructor() {
  try {
    return new Function("return (async function(){}).constructor")();
  } catch (e) {
    if (e instanceof SyntaxError) {
      throw EtaErr("This environment doesn't support async/await");
    } else {
      throw e;
    }
  }
}
function trimLeft(str) {
  if (!!String.prototype.trimLeft) {
    return str.trimLeft();
  } else {
    return str.replace(/^\s+/, "");
  }
}
function trimRight(str) {
  if (!!String.prototype.trimRight) {
    return str.trimRight();
  } else {
    return str.replace(/\s+$/, "");
  }
}
function hasOwnProp(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}
function copyProps(toObj, fromObj) {
  for (var key in fromObj) {
    if (hasOwnProp(fromObj, key)) {
      toObj[key] = fromObj[key];
    }
  }
  return toObj;
}
function trimWS(str, config2, wsLeft, wsRight) {
  var leftTrim;
  var rightTrim;
  if (Array.isArray(config2.autoTrim)) {
    leftTrim = config2.autoTrim[1];
    rightTrim = config2.autoTrim[0];
  } else {
    leftTrim = rightTrim = config2.autoTrim;
  }
  if (wsLeft || wsLeft === false) {
    leftTrim = wsLeft;
  }
  if (wsRight || wsRight === false) {
    rightTrim = wsRight;
  }
  if (!rightTrim && !leftTrim) {
    return str;
  }
  if (leftTrim === "slurp" && rightTrim === "slurp") {
    return str.trim();
  }
  if (leftTrim === "_" || leftTrim === "slurp") {
    str = trimLeft(str);
  } else if (leftTrim === "-" || leftTrim === "nl") {
    str = str.replace(/^(?:\r\n|\n|\r)/, "");
  }
  if (rightTrim === "_" || rightTrim === "slurp") {
    str = trimRight(str);
  } else if (rightTrim === "-" || rightTrim === "nl") {
    str = str.replace(/(?:\r\n|\n|\r)$/, "");
  }
  return str;
}
var escMap = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#39;"
};
function replaceChar(s) {
  return escMap[s];
}
function XMLEscape(str) {
  var newStr = String(str);
  if (/[&<>"']/.test(newStr)) {
    return newStr.replace(/[&<>"']/g, replaceChar);
  } else {
    return newStr;
  }
}
var templateLitReg = /`(?:\\[\s\S]|\${(?:[^{}]|{(?:[^{}]|{[^}]*})*})*}|(?!\${)[^\\`])*`/g;
var singleQuoteReg = /'(?:\\[\s\w"'\\`]|[^\n\r'\\])*?'/g;
var doubleQuoteReg = /"(?:\\[\s\w"'\\`]|[^\n\r"\\])*?"/g;
function escapeRegExp(string) {
  return string.replace(/[.*+\-?^${}()|[\]\\]/g, "\\$&");
}
function parse(str, config2) {
  var buffer = [];
  var trimLeftOfNextStr = false;
  var lastIndex = 0;
  var parseOptions = config2.parse;
  if (config2.plugins) {
    for (var i = 0; i < config2.plugins.length; i++) {
      var plugin = config2.plugins[i];
      if (plugin.processTemplate) {
        str = plugin.processTemplate(str, config2);
      }
    }
  }
  if (config2.rmWhitespace) {
    str = str.replace(/[\r\n]+/g, "\n").replace(/^\s+|\s+$/gm, "");
  }
  templateLitReg.lastIndex = 0;
  singleQuoteReg.lastIndex = 0;
  doubleQuoteReg.lastIndex = 0;
  function pushString(strng, shouldTrimRightOfString) {
    if (strng) {
      strng = trimWS(strng, config2, trimLeftOfNextStr, shouldTrimRightOfString);
      if (strng) {
        strng = strng.replace(/\\|'/g, "\\$&").replace(/\r\n|\n|\r/g, "\\n");
        buffer.push(strng);
      }
    }
  }
  var prefixes = [parseOptions.exec, parseOptions.interpolate, parseOptions.raw].reduce(function(accumulator, prefix2) {
    if (accumulator && prefix2) {
      return accumulator + "|" + escapeRegExp(prefix2);
    } else if (prefix2) {
      return escapeRegExp(prefix2);
    } else {
      return accumulator;
    }
  }, "");
  var parseOpenReg = new RegExp("([^]*?)" + escapeRegExp(config2.tags[0]) + "(-|_)?\\s*(" + prefixes + ")?\\s*", "g");
  var parseCloseReg = new RegExp("'|\"|`|\\/\\*|(\\s*(-|_)?" + escapeRegExp(config2.tags[1]) + ")", "g");
  var m;
  while (m = parseOpenReg.exec(str)) {
    lastIndex = m[0].length + m.index;
    var precedingString = m[1];
    var wsLeft = m[2];
    var prefix = m[3] || "";
    pushString(precedingString, wsLeft);
    parseCloseReg.lastIndex = lastIndex;
    var closeTag = void 0;
    var currentObj = false;
    while (closeTag = parseCloseReg.exec(str)) {
      if (closeTag[1]) {
        var content = str.slice(lastIndex, closeTag.index);
        parseOpenReg.lastIndex = lastIndex = parseCloseReg.lastIndex;
        trimLeftOfNextStr = closeTag[2];
        var currentType = prefix === parseOptions.exec ? "e" : prefix === parseOptions.raw ? "r" : prefix === parseOptions.interpolate ? "i" : "";
        currentObj = { t: currentType, val: content };
        break;
      } else {
        var char = closeTag[0];
        if (char === "/*") {
          var commentCloseInd = str.indexOf("*/", parseCloseReg.lastIndex);
          if (commentCloseInd === -1) {
            ParseErr("unclosed comment", str, closeTag.index);
          }
          parseCloseReg.lastIndex = commentCloseInd;
        } else if (char === "'") {
          singleQuoteReg.lastIndex = closeTag.index;
          var singleQuoteMatch = singleQuoteReg.exec(str);
          if (singleQuoteMatch) {
            parseCloseReg.lastIndex = singleQuoteReg.lastIndex;
          } else {
            ParseErr("unclosed string", str, closeTag.index);
          }
        } else if (char === '"') {
          doubleQuoteReg.lastIndex = closeTag.index;
          var doubleQuoteMatch = doubleQuoteReg.exec(str);
          if (doubleQuoteMatch) {
            parseCloseReg.lastIndex = doubleQuoteReg.lastIndex;
          } else {
            ParseErr("unclosed string", str, closeTag.index);
          }
        } else if (char === "`") {
          templateLitReg.lastIndex = closeTag.index;
          var templateLitMatch = templateLitReg.exec(str);
          if (templateLitMatch) {
            parseCloseReg.lastIndex = templateLitReg.lastIndex;
          } else {
            ParseErr("unclosed string", str, closeTag.index);
          }
        }
      }
    }
    if (currentObj) {
      buffer.push(currentObj);
    } else {
      ParseErr("unclosed tag", str, m.index + precedingString.length);
    }
  }
  pushString(str.slice(lastIndex, str.length), false);
  if (config2.plugins) {
    for (var i = 0; i < config2.plugins.length; i++) {
      var plugin = config2.plugins[i];
      if (plugin.processAST) {
        buffer = plugin.processAST(buffer, config2);
      }
    }
  }
  return buffer;
}
function compileToString(str, config2) {
  var buffer = parse(str, config2);
  var res = "var tR='',__l,__lP" + (config2.include ? ",include=E.include.bind(E)" : "") + (config2.includeFile ? ",includeFile=E.includeFile.bind(E)" : "") + "\nfunction layout(p,d){__l=p;__lP=d}\n" + (config2.useWith ? "with(" + config2.varName + "||{}){" : "") + compileScope(buffer, config2) + (config2.includeFile ? "if(__l)tR=" + (config2.async ? "await " : "") + ("includeFile(__l,Object.assign(" + config2.varName + ",{body:tR},__lP))\n") : config2.include ? "if(__l)tR=" + (config2.async ? "await " : "") + ("include(__l,Object.assign(" + config2.varName + ",{body:tR},__lP))\n") : "") + "if(cb){cb(null,tR)} return tR" + (config2.useWith ? "}" : "");
  if (config2.plugins) {
    for (var i = 0; i < config2.plugins.length; i++) {
      var plugin = config2.plugins[i];
      if (plugin.processFnString) {
        res = plugin.processFnString(res, config2);
      }
    }
  }
  return res;
}
function compileScope(buff, config2) {
  var i = 0;
  var buffLength = buff.length;
  var returnStr = "";
  for (i; i < buffLength; i++) {
    var currentBlock = buff[i];
    if (typeof currentBlock === "string") {
      var str = currentBlock;
      returnStr += "tR+='" + str + "'\n";
    } else {
      var type = currentBlock.t;
      var content = currentBlock.val || "";
      if (type === "r") {
        if (config2.filter) {
          content = "E.filter(" + content + ")";
        }
        returnStr += "tR+=" + content + "\n";
      } else if (type === "i") {
        if (config2.filter) {
          content = "E.filter(" + content + ")";
        }
        if (config2.autoEscape) {
          content = "E.e(" + content + ")";
        }
        returnStr += "tR+=" + content + "\n";
      } else if (type === "e") {
        returnStr += content + "\n";
      }
    }
  }
  return returnStr;
}
var Cacher = function() {
  function Cacher2(cache) {
    this.cache = cache;
  }
  Cacher2.prototype.define = function(key, val) {
    this.cache[key] = val;
  };
  Cacher2.prototype.get = function(key) {
    return this.cache[key];
  };
  Cacher2.prototype.remove = function(key) {
    delete this.cache[key];
  };
  Cacher2.prototype.reset = function() {
    this.cache = {};
  };
  Cacher2.prototype.load = function(cacheObj) {
    copyProps(this.cache, cacheObj);
  };
  return Cacher2;
}();
var templates = new Cacher({});
function includeHelper(templateNameOrPath, data) {
  var template = this.templates.get(templateNameOrPath);
  if (!template) {
    throw EtaErr('Could not fetch template "' + templateNameOrPath + '"');
  }
  return template(data, this);
}
var config = {
  async: false,
  autoEscape: true,
  autoTrim: [false, "nl"],
  cache: false,
  e: XMLEscape,
  include: includeHelper,
  parse: {
    exec: "",
    interpolate: "=",
    raw: "~"
  },
  plugins: [],
  rmWhitespace: false,
  tags: ["<%", "%>"],
  templates,
  useWith: false,
  varName: "it"
};
function getConfig(override, baseConfig) {
  var res = {};
  copyProps(res, config);
  if (baseConfig) {
    copyProps(res, baseConfig);
  }
  if (override) {
    copyProps(res, override);
  }
  return res;
}
function configure(options) {
  return copyProps(config, options);
}
function compile(str, config2) {
  var options = getConfig(config2 || {});
  var ctor = options.async ? getAsyncFunctionConstructor() : Function;
  try {
    return new ctor(options.varName, "E", "cb", compileToString(str, options));
  } catch (e) {
    if (e instanceof SyntaxError) {
      throw EtaErr("Bad template syntax\n\n" + e.message + "\n" + Array(e.message.length + 1).join("=") + "\n" + compileToString(str, options) + "\n");
    } else {
      throw e;
    }
  }
}
var _BOM = /^\uFEFF/;
function getWholeFilePath(name, parentfile, isDirectory) {
  var includePath = (0, import_path.resolve)(isDirectory ? parentfile : (0, import_path.dirname)(parentfile), name) + ((0, import_path.extname)(name) ? "" : ".eta");
  return includePath;
}
function getPath(path, options) {
  var includePath = false;
  var views = options.views;
  var searchedPaths = [];
  var pathOptions = JSON.stringify({
    filename: options.filename,
    path,
    root: options.root,
    views: options.views
  });
  if (options.cache && options.filepathCache && options.filepathCache[pathOptions]) {
    return options.filepathCache[pathOptions];
  }
  function addPathToSearched(pathSearched) {
    if (!searchedPaths.includes(pathSearched)) {
      searchedPaths.push(pathSearched);
    }
  }
  function searchViews(views2, path2) {
    var filePath2;
    if (Array.isArray(views2) && views2.some(function(v) {
      filePath2 = getWholeFilePath(path2, v, true);
      addPathToSearched(filePath2);
      return (0, import_fs.existsSync)(filePath2);
    })) {
      return filePath2;
    } else if (typeof views2 === "string") {
      filePath2 = getWholeFilePath(path2, views2, true);
      addPathToSearched(filePath2);
      if ((0, import_fs.existsSync)(filePath2)) {
        return filePath2;
      }
    }
    return false;
  }
  var match = /^[A-Za-z]+:\\|^\//.exec(path);
  if (match && match.length) {
    var formattedPath = path.replace(/^\/*/, "");
    includePath = searchViews(views, formattedPath);
    if (!includePath) {
      var pathFromRoot = getWholeFilePath(formattedPath, options.root || "/", true);
      addPathToSearched(pathFromRoot);
      includePath = pathFromRoot;
    }
  } else {
    if (options.filename) {
      var filePath = getWholeFilePath(path, options.filename);
      addPathToSearched(filePath);
      if ((0, import_fs.existsSync)(filePath)) {
        includePath = filePath;
      }
    }
    if (!includePath) {
      includePath = searchViews(views, path);
    }
    if (!includePath) {
      throw EtaErr('Could not find the template "' + path + '". Paths tried: ' + searchedPaths);
    }
  }
  if (options.cache && options.filepathCache) {
    options.filepathCache[pathOptions] = includePath;
  }
  return includePath;
}
function readFile(filePath) {
  try {
    return (0, import_fs.readFileSync)(filePath).toString().replace(_BOM, "");
  } catch (_a) {
    throw EtaErr("Failed to read template at '" + filePath + "'");
  }
}
function loadFile(filePath, options, noCache) {
  var config2 = getConfig(options);
  var template = readFile(filePath);
  try {
    var compiledTemplate = compile(template, config2);
    if (!noCache) {
      config2.templates.define(config2.filename, compiledTemplate);
    }
    return compiledTemplate;
  } catch (e) {
    throw EtaErr("Loading file: " + filePath + " failed:\n\n" + e.message);
  }
}
function handleCache(options) {
  var filename = options.filename;
  if (options.cache) {
    var func = options.templates.get(filename);
    if (func) {
      return func;
    }
    return loadFile(filename, options);
  }
  return loadFile(filename, options, true);
}
function includeFile(path, options) {
  var newFileOptions = getConfig({ filename: getPath(path, options) }, options);
  return [handleCache(newFileOptions), newFileOptions];
}
function includeFileHelper(path, data) {
  var templateAndConfig = includeFile(path, this);
  return templateAndConfig[0](data, templateAndConfig[1]);
}
function handleCache$1(template, options) {
  if (options.cache && options.name && options.templates.get(options.name)) {
    return options.templates.get(options.name);
  }
  var templateFunc = typeof template === "function" ? template : compile(template, options);
  if (options.cache && options.name) {
    options.templates.define(options.name, templateFunc);
  }
  return templateFunc;
}
function render(template, data, config2, cb) {
  var options = getConfig(config2 || {});
  if (options.async) {
    if (cb) {
      try {
        var templateFn = handleCache$1(template, options);
        templateFn(data, options, cb);
      } catch (err) {
        return cb(err);
      }
    } else {
      if (typeof promiseImpl === "function") {
        return new promiseImpl(function(resolve2, reject) {
          try {
            resolve2(handleCache$1(template, options)(data, options));
          } catch (err) {
            reject(err);
          }
        });
      } else {
        throw EtaErr("Please provide a callback function, this env doesn't support Promises");
      }
    }
  } else {
    return handleCache$1(template, options)(data, options);
  }
}
config.includeFile = includeFileHelper;
config.filepathCache = {};

// src/snippetor-Snippetor-Templates.ts
var SIMPLE_TASK = `
@charset "UTF-8";
/*
Generated by Snippetor on <%= it.date %>.
This file will be overwritten if you push the button again...
*/

<% if (it.cfg.clearThemeBackground) { %>
/** Clear settings from other themes */
.checklist-plugin-main .group .compact > .toggle .checked,
.is-flashing input[type=checkbox]:checked,
input[type=checkbox]:checked {
    background-color: unset !important;
}
<% } %>

.markdown-source-view.mod-cm6 input.task-list-item-checkbox,
.markdown-preview-view input.task-list-item-checkbox {
    -webkit-appearance: none;
    box-sizing: border-box;
    transition: background-color 200ms ease-out 0s;
    cursor: pointer;
    filter: none;
    border: 1px solid var(--text-normal);
    border-radius: 2px;
    margin-top: 2px;
    margin-bottom: 2px;
}
.markdown-source-view.mod-cm6 input.task-list-item-checkbox:checked::before,
.markdown-preview-view input.task-list-item-checkbox:checked::before {
    font-family: var(--font-monospace);
    position: absolute;
    text-align: center;
    font-weight: 500;
    line-height: 14px;
    font-size: 14px;
    left: 1px;
    right: 1px;
}
.markdown-source-view.mod-cm6 input.task-list-item-checkbox::before,
.markdown-preview-view ul > li > input.task-list-item-checkbox:checked::before,
.markdown-preview-view ul > li > p > input.task-list-item-checkbox:checked::before {
    content: "\u2713";
    color: var(--text-normal);
}
.markdown-source-view.mod-cm6 input.task-list-item-checkbox,
.markdown-preview-view ul > li > input.task-list-item-checkbox,
.markdown-preview-view ul > li > p > input.task-list-item-checkbox {
    border-color: var(--text-normal);
    color: var(--text-normal);
}
.markdown-preview-view ul > li.task-list-item {
    font-weight: normal;
    color: var(--text-normal);
}
.markdown-source-view.mod-cm6 .HyperMD-task-line[data-task]:not([data-task=" "]),
.markdown-source-view.mod-cm6 input.task-list-item-checkbox + span,
.markdown-source-view.mod-cm6 input.task-list-item-checkbox + span + span,
.markdown-preview-view ul > li.task-list-item.is-checked {
    color: var(--text-normal);
    text-decoration: none;
}
<% for (let i = 0; i < it.cfg.taskSettings.length; i++) {
   let ts = it.cfg.taskSettings[i]; %>
/* '<%~ ts.data %>' for completed task ('- [<%~ ts.data %>]') */
.theme-dark {
    --snippetor-checkbox-<%= i %>: <%= ts.taskColorDark %>;
}
.theme-dark .print,
.theme-light {
    --snippetor-checkbox-<%= i %>: <%= ts.taskColorLight %>;
}
.markdown-source-view.mod-cm6 input.task-list-item-checkbox[data-task="<%~ ts.data %>"]::before,
.markdown-preview-view ul > li[data-task="<%~ ts.data %>"] > input.task-list-item-checkbox:checked::before,
.markdown-preview-view ul > li[data-task="<%~ ts.data %>"] > p > input.task-list-item-checkbox:checked::before {
<% if (ts.reader) { %>
    content: "<%= ts.reader %>";
<% } else { %>
    content: "<%~ ts.data %>";
<% } %>
    color: var(--snippetor-checkbox-<%= i %>);
}
.markdown-source-view.mod-cm6 input.task-list-item-checkbox[data-task="<%~ ts.data %>"],
.markdown-preview-view ul > li[data-task="<%~ ts.data %>"] > input.task-list-item-checkbox,
.markdown-preview-view ul > li[data-task="<%~ ts.data %>"] > p > input.task-list-item-checkbox {
    border-color: var(--snippetor-checkbox-<%= i %>);
    color: var(--snippetor-checkbox-<%= i %>);
}
<% if (ts.strkethrough || ts.applyTextColor) { %>
.markdown-source-view.mod-cm6 .HyperMD-task-line[data-task="<%~ ts.data %>"],
.markdown-source-view.mod-cm6 input.task-list-item-checkbox[data-task="<%~ ts.data %>"] + span,
.markdown-source-view.mod-cm6 input.task-list-item-checkbox[data-task="<%~ ts.data %>"] + span + span,
.markdown-preview-view ul > li[data-task="<%~ ts.data %>"].task-list-item.is-checked {
<% if (ts.strkethrough) { %>
    text-decoration: line-through;
<% } %>
<% if (ts.applyTextColor) { %>
    color: var(--snippetor-checkbox-<%= i %>);
<% } %>
}
<% } %>

<% } %>

/* Consistent hover colors */
.markdown-source-view.mod-cm6 input.task-list-item-checkbox:hover,
.markdown-source-view.mod-cm6 input.task-list-item-checkbox:checked:hover,
<% it.cfg.taskSettings.forEach(function(ts){ %>
.markdown-preview-view li[data-task="<%~ ts.data %>"] > input.task-list-item-checkbox:checked:hover,
.markdown-preview-view li[data-task="<%~ ts.data %>"] > p > input.task-list-item-checkbox:checked:hover,
<% }) %>
.markdown-preview-view input.task-list-item-checkbox:hover {
    color: var(--text-on-accent) !important;
    background-color: var(--interactive-accent-hover);
    border-color: var(--text-on-accent) !important;
}
`;

// src/snippetor-Snippetor.ts
var import_random_word_slugs3 = __toModule(require_dist());
var import_randomcolor = __toModule(require_randomColor());
var Snippetor = class {
  constructor(app) {
    this.app = app;
    configure({
      cache: true,
      async: false
    });
  }
  get canUseTaskCollector() {
    return this.app.plugins.enabledPlugins.has("obsidian-task-collector");
  }
  get taskValues() {
    let values = this.app.plugins.plugins["obsidian-task-collector"].taskCollector.settings.incompleteTaskValues;
    if (this.app.plugins.plugins["obsidian-task-collector"].taskCollector.settings.supportCanceledTasks) {
      values += "-";
    }
    const tasks = (values + "xX").replace(" ", "").split("");
    tasks.sort();
    return new Set(tasks);
  }
  createNewTaskSnippetCfg() {
    const result = Object.assign({}, DEFAULT_TASK_SNIPPET_SETTINGS, {
      name: (0, import_random_word_slugs3.generateSlug)(2),
      taskSettings: []
    });
    let values = new Set(["x", "-", ">"]);
    if (this.canUseTaskCollector) {
      values = this.taskValues;
    }
    values.forEach((v) => {
      result.taskSettings.push(this.createNewTaskCfg(v));
    });
    return result;
  }
  createNewTaskCfg(v) {
    return {
      data: v,
      taskColorLight: (0, import_randomcolor.default)({
        luminosity: "dark"
      }),
      taskColorDark: (0, import_randomcolor.default)({
        luminosity: "light"
      })
    };
  }
  generateCss(cfg) {
    console.log("Create CSS file for snippet %o", cfg);
    if (!cfg.name) {
      new import_obsidian3.Notice("Unable to create snippet: Missing file name.");
      return Promise.reject();
    }
    let snippet;
    if (this.isTaskSnippetConfig(cfg)) {
      snippet = render(SIMPLE_TASK, {
        date: new Date(),
        cfg
      });
    }
    if (!snippet) {
      new import_obsidian3.Notice("Unable to create snippet: Content is empty. Check console for details.");
      return Promise.reject();
    }
    const fileName = cfg.type + "-" + cfg.name;
    const path = this.app.customCss.getSnippetPath(fileName);
    let update;
    if (this.app.customCss.snippets.includes(fileName)) {
      update = this.app.vault.adapter.write(path, snippet).then(() => {
        new import_obsidian3.Notice("Snippet created successfully.");
      }, (reason) => {
        new import_obsidian3.Notice("Snippet creation failed. Check console for details.");
        console.error("Snippet creation failed: %o", reason);
      });
    } else {
      update = this.app.vault.create(path, snippet).then(() => {
        new import_obsidian3.Notice("Snippet created successfully.");
      }, (reason) => {
        new import_obsidian3.Notice("Snippet creation failed. Check console for details.");
        console.error("Snippet creation failed: %o", reason);
      });
    }
    return update;
  }
  isTaskSnippetConfig(cfg) {
    return cfg.type === DEFAULT_TASK_SNIPPET_SETTINGS.type;
  }
};

// src/snippetor-Plugin.ts
var SnippetorPlugin = class extends import_obsidian4.Plugin {
  onload() {
    return __async(this, null, function* () {
      this.snippetor = new Snippetor(this.app);
      yield this.loadSettings();
      console.debug("loaded Snippetor %s: %o", this.manifest.version, this.settings);
      (0, import_obsidian4.addIcon)(MAKE_IT_SO, MAGIC_WAND);
      this.addSettingTab(new SnippetorSettingsTab(this.app, this));
    });
  }
  onunload() {
    console.debug("unloading Snippetor");
  }
  loadSettings() {
    return __async(this, null, function* () {
      const options = yield this.loadData();
      this.settings = Object.assign({}, DEFAULT_SETTINGS, options);
    });
  }
  saveSettings() {
    return __async(this, null, function* () {
      console.debug("Snippetor: saving settings");
      yield this.saveData(this.settings);
    });
  }
  removeSnippet(snippetCfg) {
    return __async(this, null, function* () {
      console.log("Removing %o", snippetCfg);
      delete this.settings.snippets[snippetCfg.name];
      return this.saveSettings();
    });
  }
  setSnippet(snippetCfg) {
    return __async(this, null, function* () {
      console.log("Updating %o with %o", this.settings, snippetCfg);
      this.settings.snippets[snippetCfg.name] = snippetCfg;
      return this.saveSettings();
    });
  }
  get allSnippets() {
    return Object.values(this.settings.snippets);
  }
};

// src/main.ts
var main_default = SnippetorPlugin;
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
