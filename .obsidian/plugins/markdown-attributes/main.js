/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __export = (target, all) => {
  __markAsModule(target);
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toModule = (module2) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// src/main.ts
__export(exports, {
  default: () => MarkdownAttributes,
  isLivePreview: () => isLivePreview
});
var import_obsidian = __toModule(require("obsidian"));
var import_view = __toModule(require("@codemirror/view"));
var import_language = __toModule(require("@codemirror/language"));
var import_stream_parser = __toModule(require("@codemirror/stream-parser"));
var import_state = __toModule(require("@codemirror/state"));

// src/processor.ts
var _Processor = class {
  constructor() {
  }
  static parse(el) {
    if (typeof el == "string") {
      return new _Processor().parseLine(el);
    } else {
      return new _Processor().recurseAndParseElements(el);
    }
  }
  parseLine(text) {
    const elements = [];
    let attribute_strings = text.matchAll(new RegExp(_Processor.END_RE.source, "gm"));
    for (const [_, match] of attribute_strings) {
      elements.push({
        attributes: this.getAttrs(match),
        text: match
      });
    }
    return elements;
  }
  getTopLevelText(el) {
    const texts = [];
    for (let child of Array.from(el.childNodes)) {
      if (child.nodeType == Node.TEXT_NODE) {
        texts.push(child.data);
      }
    }
    return texts.join("");
  }
  getAttrs(str) {
    const trys = (str != null ? str : "").split(/\s(?=(?:[^'"`]*(['"`])[^'"`]*\1)*[^'"`]*$)/).map((t) => t && t.trim()).filter((t) => t && t !== '"' && t !== "'" && t.length);
    if (!trys || !trys.length)
      return;
    const allowedKeyChars = /[^\t\n\f />"'=]/;
    const keySeparator = "=";
    const classChar = ".";
    const attrs = [];
    for (let pair of trys) {
      if (!pair || !pair.length)
        continue;
      if (pair.charAt(0) === classChar) {
        attrs.push(["class", pair.slice(1)]);
        continue;
      }
      if (new RegExp(keySeparator).test(pair) && allowedKeyChars.test(pair.slice(0, pair.indexOf(keySeparator)))) {
        attrs.push([...pair.split(keySeparator, 2)]);
        continue;
      }
      attrs.push([pair, null]);
    }
    return attrs;
  }
  recurseAndParseElements(el) {
    var _a, _b, _c;
    const elements = [];
    const text = this.getTopLevelText(el);
    if (_Processor.BLOCK_RE.test(text)) {
      let element = el;
      if (el instanceof HTMLLIElement || (el == null ? void 0 : el.parentElement) instanceof HTMLQuoteElement || (el == null ? void 0 : el.hasClass("callout"))) {
        element = el.parentElement;
      }
      let [original, attribute_string] = (_a = text.match(_Processor.BLOCK_RE)) != null ? _a : [];
      const toAdd = {
        element,
        attributes: this.getAttrs(attribute_string),
        text: attribute_string
      };
      elements.push(toAdd);
      el.innerHTML = this.tryToReplace(toAdd.element, el.innerHTML, toAdd.attributes, original);
      if (el instanceof HTMLLIElement) {
        elements.push(...this.recurseAndParseElements(el));
      }
    } else if (_Processor.BASE_RE.test(text)) {
      let textNode = Array.from(el.childNodes).find((node) => node.nodeType == Node.TEXT_NODE && _Processor.BASE_RE.test(text));
      let sibling = (_b = Array.from(el.children).find((node) => node.nextSibling == textNode)) != null ? _b : el;
      if (sibling && sibling.hasClass("collapse-indicator")) {
        sibling = sibling.parentElement;
      }
      if (sibling && sibling instanceof HTMLBRElement) {
        sibling = sibling.parentElement;
      }
      let [original, attribute_string] = (_c = text.match(_Processor.BASE_RE)) != null ? _c : [];
      const toAdd = {
        element: sibling,
        attributes: this.getAttrs(attribute_string),
        text: attribute_string
      };
      elements.push(toAdd);
      textNode.textContent = this.tryToReplace(toAdd.element, textNode.textContent, toAdd.attributes, original);
    }
    for (let child of Array.from(el.children)) {
      if (!(child instanceof HTMLElement))
        continue;
      if (child instanceof HTMLPreElement || child.tagName.toLowerCase() === "code")
        continue;
      elements.push(...this.recurseAndParseElements(child));
    }
    return elements;
  }
  tryToReplace(element, content, attributes, original) {
    if (!attributes || !attributes.length) {
      return content;
    }
    for (let [key, value] of attributes) {
      if (!key)
        continue;
      if (value)
        value = value.replace(/("|')/g, "");
      try {
        if (key === "class") {
          element.addClasses(value.split(" "));
        } else if (!value) {
          element.setAttr(key, true);
        } else {
          element.setAttr(key, value);
        }
      } catch (e) {
        console.log(`Markdown Attributes: ${key} is not a valid attribute.`);
        return content;
      }
    }
    return content.replace(original, "");
  }
};
var Processor = _Processor;
__publicField(Processor, "BASE_RE", /\{\:?[ ]*([^\}\n ][^\}\n]*)[ ]*\}/);
__publicField(Processor, "ONLY_RE", /^\{\:?[ ]*([^\}\n ][^\}\n]*)[ ]*\}$/);
__publicField(Processor, "BLOCK_RE", /\n[ ]*\{\:?[ ]*([^\}\n ][^\}\n]*)[ ]*\}[ ]*$/);
__publicField(Processor, "END_RE", /\{\:?[ ]*([^\}\n ][^\}\n]*)[ ]*\}$/m);

// src/main.ts
var isLivePreview = (state) => {
  var _a;
  if (import_obsidian.requireApiVersion && (0, import_obsidian.requireApiVersion)("0.13.23")) {
    return state.field(import_obsidian.editorLivePreviewField);
  } else {
    const md = state.field(import_obsidian.editorViewField);
    const { state: viewState } = (_a = md.leaf.getViewState()) != null ? _a : {};
    return viewState && viewState.mode == "source" && viewState.source == false;
  }
};
var MarkdownAttributes = class extends import_obsidian.Plugin {
  constructor() {
    super(...arguments);
    __publicField(this, "parsing", /* @__PURE__ */ new Map());
  }
  onload() {
    return __async(this, null, function* () {
      console.log(`Markdown Attributes v${this.manifest.version} loaded.`);
      this.registerMarkdownPostProcessor(this.postprocessor.bind(this));
      this.registerEditorExtension(this.state());
    });
  }
  postprocessor(topElement, ctx) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      const child = topElement.firstElementChild;
      if (!child)
        return;
      let str;
      if (child instanceof HTMLPreElement) {
        if (!ctx.getSectionInfo(topElement))
          return;
        const { lineStart } = ctx.getSectionInfo(topElement);
        const file = this.app.vault.getAbstractFileByPath(ctx.sourcePath);
        if (!(file instanceof import_obsidian.TFile))
          return;
        const text = yield this.app.vault.cachedRead(file);
        let source = text.split("\n").slice(lineStart, lineStart + 1);
        str = source.join("\n");
        if (!Processor.BASE_RE.test(str))
          return;
        let [attribute_string] = (_a = str.match(Processor.BASE_RE)) != null ? _a : [];
        child.prepend(new Text(attribute_string));
      }
      if (child instanceof HTMLTableElement || child.hasClass("math") && child.hasClass("math-block") || child.hasClass("callout")) {
        if (!ctx.getSectionInfo(topElement))
          return;
        const { text, lineEnd } = ctx.getSectionInfo(topElement);
        const adjustment = child.hasClass("callout") ? 0 : 1;
        let source = ((_b = text.split("\n").slice(lineEnd + adjustment, lineEnd + adjustment + 1)) != null ? _b : []).shift();
        if (source && source.length && Processor.ONLY_RE.test(source.trim())) {
          let [attribute_string] = (_c = source.match(Processor.ONLY_RE)) != null ? _c : [];
          child.prepend(new Text(attribute_string));
          str = topElement.innerText;
        }
      }
      if (child instanceof HTMLParagraphElement && !child.childElementCount) {
        if (Processor.ONLY_RE.test(child.innerText.trim())) {
          child.detach();
          return;
        }
      }
      if (!Processor.BASE_RE.test(str != null ? str : topElement.innerText))
        return;
      if (!(child instanceof HTMLElement))
        return;
      Processor.parse(child);
    });
  }
  state() {
    class StatefulDecorationSet {
      constructor(editor) {
        __publicField(this, "editor");
        __publicField(this, "replacers", Object.create(null));
        __publicField(this, "markers", Object.create(null));
        this.editor = editor;
      }
      compute(tokens) {
        return __async(this, null, function* () {
          console.log(this.replacers);
          const replace2 = [];
          for (let token of tokens) {
            const deco = import_view.Decoration.replace({
              inclusive: true,
              loc: token.loc
            });
            const marker = import_view.Decoration.mark({
              inclusive: true,
              attributes: Object.fromEntries(token.attributes),
              loc: token.loc
            });
            replace2.push(deco.range(token.from, token.to), marker.range(token.loc.from, token.loc.to));
          }
          return import_view.Decoration.set(replace2, true);
        });
      }
      updateDecos(tokens) {
        return __async(this, null, function* () {
          const replacers = yield this.compute(tokens);
          if (replace || this.editor.state.field(field).size) {
            this.editor.dispatch({
              effects: [replace.of(replacers != null ? replacers : import_view.Decoration.none)]
            });
          }
        });
      }
    }
    const plugin = import_view.ViewPlugin.fromClass(class {
      constructor(view) {
        __publicField(this, "manager");
        __publicField(this, "source", false);
        this.manager = new StatefulDecorationSet(view);
        this.build(view);
      }
      update(update) {
        if (!isLivePreview(update.view.state)) {
          if (this.source == false) {
            this.source = true;
            this.manager.updateDecos([]);
          }
          return;
        }
        if (update.docChanged || update.viewportChanged || update.selectionSet || this.source == true) {
          this.source = false;
          this.build(update.view);
        }
      }
      destroy() {
      }
      build(view) {
        if (!isLivePreview(view.state))
          return;
        const targetElements = [];
        for (let { from, to } of view.visibleRanges) {
          console.log("\u{1F680} ~ file: main.ts ~ line 216 ~ from", from);
          const tree = (0, import_language.syntaxTree)(view.state);
          tree.iterate({
            from,
            to,
            enter: (type, from2, to2) => {
              var _a;
              const tokenProps = type.prop(import_stream_parser.tokenClassNodeProp);
              const props = new Set(tokenProps == null ? void 0 : tokenProps.split(" "));
              if (props.has("hmd-codeblock") && !props.has("formatting-code-block"))
                return;
              const original = view.state.doc.sliceString(from2, to2);
              if (!Processor.END_RE.test(original))
                return;
              const parsed = (_a = Processor.parse(original)) != null ? _a : [];
              for (const item of parsed) {
                const { attributes, text } = item;
                const end = original.indexOf(text) + text.length;
                const match = original.trim().match(new RegExp(`\\{\\s?${text}s?\\}$`, "m"));
                targetElements.push({
                  from: from2 + match.index - 1,
                  to: from2 + match.index + match[0].length,
                  loc: { from: from2, to: from2 + end },
                  value: match[0],
                  attributes,
                  index: match.index
                });
              }
            }
          });
        }
        this.manager.updateDecos(targetElements);
      }
    });
    const replace = import_state.StateEffect.define();
    const field = import_state.StateField.define({
      create() {
        return import_view.Decoration.none;
      },
      update(deco, tr) {
        return tr.effects.reduce((deco2, effect) => {
          if (effect.is(replace))
            return effect.value.update({
              filter: (_, __, decoration) => {
                return !rangesInclude(tr.newSelection.ranges, decoration.spec.loc.from, decoration.spec.loc.to);
              }
            });
          return deco2;
        }, deco.map(tr.changes));
      },
      provide: (field2) => import_view.EditorView.decorations.from(field2)
    });
    return [field, plugin];
  }
  isLivePreview(state) {
    var _a;
    if (import_obsidian.requireApiVersion && (0, import_obsidian.requireApiVersion)("0.13.23")) {
      return state.field(import_obsidian.editorLivePreviewField);
    } else {
      const md = state.field(import_obsidian.editorViewField);
      const { state: viewState } = (_a = md.leaf.getViewState()) != null ? _a : {};
      return viewState && viewState.mode == "source" && viewState.source == false;
    }
  }
  onunload() {
    return __async(this, null, function* () {
      console.log("Markdown Attributes unloaded");
    });
  }
};
function rangesInclude(ranges, from, to) {
  for (const range of ranges) {
    const { from: rFrom, to: rTo } = range;
    if (rFrom >= from && rFrom <= to)
      return true;
    if (rTo >= from && rTo <= to)
      return true;
    if (rFrom < from && rTo > to)
      return true;
  }
  return false;
}
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiLi4vLi4vLi4vLi4vR2l0SHViL1BlcnNvbmFsL29ic2lkaWFuLW1hcmtkb3duLWF0dHJpYnV0ZXMvc3JjL21haW4udHMiLCAiLi4vLi4vLi4vLi4vR2l0SHViL1BlcnNvbmFsL29ic2lkaWFuLW1hcmtkb3duLWF0dHJpYnV0ZXMvc3JjL3Byb2Nlc3Nvci50cyJdLAogICJzb3VyY2VzQ29udGVudCI6IFsiaW1wb3J0IHtcclxuICAgIGVkaXRvckxpdmVQcmV2aWV3RmllbGQsXHJcbiAgICBlZGl0b3JWaWV3RmllbGQsXHJcbiAgICBNYXJrZG93blBvc3RQcm9jZXNzb3JDb250ZXh0LFxyXG4gICAgUGx1Z2luLFxyXG4gICAgcmVxdWlyZUFwaVZlcnNpb24sXHJcbiAgICBURmlsZVxyXG59IGZyb20gXCJvYnNpZGlhblwiO1xyXG5pbXBvcnQgeyBSYW5nZSB9IGZyb20gXCJAY29kZW1pcnJvci9yYW5nZXNldFwiO1xyXG5pbXBvcnQge1xyXG4gICAgRWRpdG9yVmlldyxcclxuICAgIERlY29yYXRpb24sXHJcbiAgICBWaWV3UGx1Z2luLFxyXG4gICAgRGVjb3JhdGlvblNldCxcclxuICAgIFZpZXdVcGRhdGVcclxufSBmcm9tIFwiQGNvZGVtaXJyb3Ivdmlld1wiO1xyXG5pbXBvcnQgeyBzeW50YXhUcmVlIH0gZnJvbSBcIkBjb2RlbWlycm9yL2xhbmd1YWdlXCI7XHJcbmltcG9ydCB7IHRva2VuQ2xhc3NOb2RlUHJvcCB9IGZyb20gXCJAY29kZW1pcnJvci9zdHJlYW0tcGFyc2VyXCI7XHJcbmltcG9ydCB7XHJcbiAgICBTZWxlY3Rpb25SYW5nZSxcclxuICAgIFN0YXRlRWZmZWN0LFxyXG4gICAgU3RhdGVGaWVsZCxcclxuICAgIEVkaXRvclN0YXRlXHJcbn0gZnJvbSBcIkBjb2RlbWlycm9yL3N0YXRlXCI7XHJcblxyXG5pbXBvcnQgUHJvY2Vzc29yIGZyb20gXCIuL3Byb2Nlc3NvclwiO1xyXG5cclxuZXhwb3J0IGNvbnN0IGlzTGl2ZVByZXZpZXcgPSAoc3RhdGU6IEVkaXRvclN0YXRlKSA9PiB7XHJcbiAgICBpZiAocmVxdWlyZUFwaVZlcnNpb24gJiYgcmVxdWlyZUFwaVZlcnNpb24oXCIwLjEzLjIzXCIpKSB7XHJcbiAgICAgICAgcmV0dXJuIHN0YXRlLmZpZWxkKGVkaXRvckxpdmVQcmV2aWV3RmllbGQpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBjb25zdCBtZCA9IHN0YXRlLmZpZWxkKGVkaXRvclZpZXdGaWVsZCk7XHJcbiAgICAgICAgY29uc3QgeyBzdGF0ZTogdmlld1N0YXRlIH0gPSBtZC5sZWFmLmdldFZpZXdTdGF0ZSgpID8/IHt9O1xyXG5cclxuICAgICAgICByZXR1cm4gKFxyXG4gICAgICAgICAgICB2aWV3U3RhdGUgJiYgdmlld1N0YXRlLm1vZGUgPT0gXCJzb3VyY2VcIiAmJiB2aWV3U3RhdGUuc291cmNlID09IGZhbHNlXHJcbiAgICAgICAgKTtcclxuICAgIH1cclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1hcmtkb3duQXR0cmlidXRlcyBleHRlbmRzIFBsdWdpbiB7XHJcbiAgICBwYXJzaW5nOiBNYXA8TWFya2Rvd25Qb3N0UHJvY2Vzc29yQ29udGV4dCwgc3RyaW5nPiA9IG5ldyBNYXAoKTtcclxuICAgIGFzeW5jIG9ubG9hZCgpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgICAgICBjb25zb2xlLmxvZyhgTWFya2Rvd24gQXR0cmlidXRlcyB2JHt0aGlzLm1hbmlmZXN0LnZlcnNpb259IGxvYWRlZC5gKTtcclxuXHJcbiAgICAgICAgdGhpcy5yZWdpc3Rlck1hcmtkb3duUG9zdFByb2Nlc3Nvcih0aGlzLnBvc3Rwcm9jZXNzb3IuYmluZCh0aGlzKSk7XHJcbiAgICAgICAgdGhpcy5yZWdpc3RlckVkaXRvckV4dGVuc2lvbih0aGlzLnN0YXRlKCkpO1xyXG4gICAgfVxyXG5cclxuICAgIGFzeW5jIHBvc3Rwcm9jZXNzb3IoXHJcbiAgICAgICAgdG9wRWxlbWVudDogSFRNTEVsZW1lbnQsXHJcbiAgICAgICAgY3R4OiBNYXJrZG93blBvc3RQcm9jZXNzb3JDb250ZXh0XHJcbiAgICApIHtcclxuICAgICAgICBjb25zdCBjaGlsZCA9IHRvcEVsZW1lbnQuZmlyc3RFbGVtZW50Q2hpbGQ7XHJcbiAgICAgICAgaWYgKCFjaGlsZCkgcmV0dXJuO1xyXG4gICAgICAgIGxldCBzdHI6IHN0cmluZztcclxuXHJcbiAgICAgICAgLyoqIENvZGUgYmxvY2tzIGhhdmUgdG8gYmUgaGFuZGxlZCBzZXBhcmF0ZWx5IGJlY2F1c2UgT2JzaWRpYW4gZG9lcyBub3RcclxuICAgICAgICAgKiAgaW5jbHVkZSBhbnkgdGV4dCBwYXN0IHRoZSBsYW5ndWFnZS5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICBVbmZvcnR1bmF0ZWx5IHRoaXMgYWxzbyBtZWFucyB0aGF0IGNoYW5nZXMgdG8gdGhlIGNvZGUgYmxvY2sgYXR0cmlidXRlc1xyXG4gICAgICAgICAqICByZXF1aXJlIHJlbG9hZGluZyB0aGUgbm90ZSB0byB0YWtlIGVmZmVjdCBiZWNhdXNlIHRoZXkgZG8gbm90IHRyaWdnZXIgdGhlIHBvc3Rwcm9jZXNzb3IuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgaWYgKGNoaWxkIGluc3RhbmNlb2YgSFRNTFByZUVsZW1lbnQpIHtcclxuICAgICAgICAgICAgLyoqIElmIGdldFNlY3Rpb25JbmZvIHJldHVybnMgbnVsbCwgc3RvcCBwcm9jZXNzaW5nLiAqL1xyXG4gICAgICAgICAgICBpZiAoIWN0eC5nZXRTZWN0aW9uSW5mbyh0b3BFbGVtZW50KSkgcmV0dXJuO1xyXG5cclxuICAgICAgICAgICAgLyoqIFB1bGwgdGhlIFNlY3Rpb24gZGF0YS4gKi9cclxuICAgICAgICAgICAgY29uc3QgeyBsaW5lU3RhcnQgfSA9IGN0eC5nZXRTZWN0aW9uSW5mbyh0b3BFbGVtZW50KTtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IGZpbGUgPSB0aGlzLmFwcC52YXVsdC5nZXRBYnN0cmFjdEZpbGVCeVBhdGgoY3R4LnNvdXJjZVBhdGgpO1xyXG4gICAgICAgICAgICBpZiAoIShmaWxlIGluc3RhbmNlb2YgVEZpbGUpKSByZXR1cm47XHJcbiAgICAgICAgICAgIGNvbnN0IHRleHQgPSBhd2FpdCB0aGlzLmFwcC52YXVsdC5jYWNoZWRSZWFkKGZpbGUpO1xyXG5cclxuICAgICAgICAgICAgLyoqIEdldCB0aGUgc291cmNlIGZvciB0aGlzIGVsZW1lbnQuIE9ubHkgbG9vayBhdCB0aGUgdG9wIGxpbmUgZm9yIGNvZGUgYmxvY2tzLiAqL1xyXG4gICAgICAgICAgICBsZXQgc291cmNlID0gdGV4dC5zcGxpdChcIlxcblwiKS5zbGljZShsaW5lU3RhcnQsIGxpbmVTdGFydCArIDEpO1xyXG4gICAgICAgICAgICBzdHIgPSBzb3VyY2Uuam9pbihcIlxcblwiKTtcclxuICAgICAgICAgICAgLyoqIFRlc3QgaWYgdGhlIGVsZW1lbnQgY29udGFpbnMgYXR0cmlidXRlcy4gKi9cclxuICAgICAgICAgICAgaWYgKCFQcm9jZXNzb3IuQkFTRV9SRS50ZXN0KHN0cikpIHJldHVybjtcclxuXHJcbiAgICAgICAgICAgIC8qKiBQdWxsIHRoZSBtYXRjaGVkIHN0cmluZyBhbmQgYWRkIGl0IHRvIHRoZSBjaGlsZCBzbyB0aGUgUHJvY2Vzc29yIGNhdGNoZXMgaXQuICovXHJcbiAgICAgICAgICAgIGxldCBbYXR0cmlidXRlX3N0cmluZ10gPSBzdHIubWF0Y2goUHJvY2Vzc29yLkJBU0VfUkUpID8/IFtdO1xyXG4gICAgICAgICAgICBjaGlsZC5wcmVwZW5kKG5ldyBUZXh0KGF0dHJpYnV0ZV9zdHJpbmcpKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRhYmxlIGVsZW1lbnRzIGFuZCBNYXRoamF4IGVsZW1lbnRzIHNob3VsZCBjaGVjayB0aGUgbmV4dCBsaW5lIGluIHRoZSBzb3VyY2UgdG8gc2VlIGlmIGl0IGlzIGEgc2luZ2xlIGJsb2NrIGF0dHJpYnV0ZSxcclxuICAgICAgICAgKiBiZWNhdXNlIHRob3NlIGJsb2NrIGF0dHJpYnV0ZXMgYXJlIG5vdCBhcHBsaWVkIHRvIHRoZSB0YWJsZS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBpZiAoXHJcbiAgICAgICAgICAgIGNoaWxkIGluc3RhbmNlb2YgSFRNTFRhYmxlRWxlbWVudCB8fFxyXG4gICAgICAgICAgICAoY2hpbGQuaGFzQ2xhc3MoXCJtYXRoXCIpICYmIGNoaWxkLmhhc0NsYXNzKFwibWF0aC1ibG9ja1wiKSkgfHxcclxuICAgICAgICAgICAgY2hpbGQuaGFzQ2xhc3MoXCJjYWxsb3V0XCIpXHJcbiAgICAgICAgKSB7XHJcbiAgICAgICAgICAgIGlmICghY3R4LmdldFNlY3Rpb25JbmZvKHRvcEVsZW1lbnQpKSByZXR1cm47XHJcblxyXG4gICAgICAgICAgICAvKiogUHVsbCB0aGUgU2VjdGlvbiBkYXRhLiAqL1xyXG4gICAgICAgICAgICBjb25zdCB7IHRleHQsIGxpbmVFbmQgfSA9IGN0eC5nZXRTZWN0aW9uSW5mbyh0b3BFbGVtZW50KTtcclxuXHJcbiAgICAgICAgICAgIC8qKiBDYWxsb3V0cyBpbmNsdWRlIHRoZSBibG9jayBsZXZlbCBhdHRyaWJ1dGUgKi9cclxuICAgICAgICAgICAgY29uc3QgYWRqdXN0bWVudCA9IGNoaWxkLmhhc0NsYXNzKFwiY2FsbG91dFwiKSA/IDAgOiAxO1xyXG5cclxuICAgICAgICAgICAgLyoqIEdldCB0aGUgc291cmNlIGZvciB0aGlzIGVsZW1lbnQuICovXHJcbiAgICAgICAgICAgIGxldCBzb3VyY2UgPSAoXHJcbiAgICAgICAgICAgICAgICB0ZXh0XHJcbiAgICAgICAgICAgICAgICAgICAgLnNwbGl0KFwiXFxuXCIpXHJcbiAgICAgICAgICAgICAgICAgICAgLnNsaWNlKGxpbmVFbmQgKyBhZGp1c3RtZW50LCBsaW5lRW5kICsgYWRqdXN0bWVudCArIDEpID8/IFtdXHJcbiAgICAgICAgICAgICkuc2hpZnQoKTtcclxuXHJcbiAgICAgICAgICAgIC8qKiBUZXN0IGlmIHRoZSBlbGVtZW50IGNvbnRhaW5zIGF0dHJpYnV0ZXMuICovXHJcbiAgICAgICAgICAgIGlmIChcclxuICAgICAgICAgICAgICAgIHNvdXJjZSAmJlxyXG4gICAgICAgICAgICAgICAgc291cmNlLmxlbmd0aCAmJlxyXG4gICAgICAgICAgICAgICAgUHJvY2Vzc29yLk9OTFlfUkUudGVzdChzb3VyY2UudHJpbSgpKVxyXG4gICAgICAgICAgICApIHtcclxuICAgICAgICAgICAgICAgIC8qKiBQdWxsIHRoZSBtYXRjaGVkIHN0cmluZyBhbmQgYWRkIGl0IHRvIHRoZSBjaGlsZCBzbyB0aGUgUHJvY2Vzc29yIGNhdGNoZXMgaXQuICovXHJcbiAgICAgICAgICAgICAgICBsZXQgW2F0dHJpYnV0ZV9zdHJpbmddID0gc291cmNlLm1hdGNoKFByb2Nlc3Nvci5PTkxZX1JFKSA/PyBbXTtcclxuICAgICAgICAgICAgICAgIGNoaWxkLnByZXBlbmQobmV3IFRleHQoYXR0cmlidXRlX3N0cmluZykpO1xyXG5cclxuICAgICAgICAgICAgICAgIHN0ciA9IHRvcEVsZW1lbnQuaW5uZXJUZXh0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBJZiB0aGUgZWxlbWVudCBpcyBhIDxwPiBhbmQgdGhlIHRleHQgaXMgKm9ubHkqIGFuIGF0dHJpYnV0ZSwgaXQgd2FzIHVzZWQgYXMgYSBibG9jayBhdHRyaWJ1dGVcclxuICAgICAgICAgKiBhbmQgc2hvdWxkIGJlIHJlbW92ZWQuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgaWYgKGNoaWxkIGluc3RhbmNlb2YgSFRNTFBhcmFncmFwaEVsZW1lbnQgJiYgIWNoaWxkLmNoaWxkRWxlbWVudENvdW50KSB7XHJcbiAgICAgICAgICAgIGlmIChQcm9jZXNzb3IuT05MWV9SRS50ZXN0KGNoaWxkLmlubmVyVGV4dC50cmltKCkpKSB7XHJcbiAgICAgICAgICAgICAgICBjaGlsZC5kZXRhY2goKTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLyoqIFRlc3QgaWYgdGhlIGVsZW1lbnQgY29udGFpbnMgYXR0cmlidXRlcy4gKi9cclxuICAgICAgICBpZiAoIVByb2Nlc3Nvci5CQVNFX1JFLnRlc3Qoc3RyID8/IHRvcEVsZW1lbnQuaW5uZXJUZXh0KSkgcmV0dXJuO1xyXG5cclxuICAgICAgICAvKiogUGFyc2UgdGhlIGVsZW1lbnQgdXNpbmcgdGhlIFByb2Nlc3Nvci4gKi9cclxuICAgICAgICBpZiAoIShjaGlsZCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSkgcmV0dXJuO1xyXG4gICAgICAgIFByb2Nlc3Nvci5wYXJzZShjaGlsZCk7XHJcbiAgICB9XHJcbiAgICBzdGF0ZSgpIHtcclxuICAgICAgICAvL2h0dHBzOi8vZ2lzdC5naXRodWIuY29tL25vdGhpbmdpc2xvc3QvZmFhODlhYTcyMzI1NDg4M2QzN2Y0NWZkMTYxNjIzMzdcclxuICAgICAgICB0eXBlIFRva2VuU3BlYyA9IHtcclxuICAgICAgICAgICAgZnJvbTogbnVtYmVyO1xyXG4gICAgICAgICAgICB0bzogbnVtYmVyO1xyXG4gICAgICAgICAgICBsb2M6IHsgZnJvbTogbnVtYmVyOyB0bzogbnVtYmVyIH07XHJcbiAgICAgICAgICAgIGF0dHJpYnV0ZXM6IFtzdHJpbmcsIHN0cmluZ11bXTtcclxuICAgICAgICAgICAgdmFsdWU6IHN0cmluZztcclxuICAgICAgICAgICAgaW5kZXg6IG51bWJlcjtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBjbGFzcyBTdGF0ZWZ1bERlY29yYXRpb25TZXQge1xyXG4gICAgICAgICAgICBlZGl0b3I6IEVkaXRvclZpZXc7XHJcbiAgICAgICAgICAgIHJlcGxhY2VyczogeyBbY2xzOiBzdHJpbmddOiBEZWNvcmF0aW9uIH0gPSBPYmplY3QuY3JlYXRlKG51bGwpO1xyXG4gICAgICAgICAgICBtYXJrZXJzOiB7IFtjbHM6IHN0cmluZ106IERlY29yYXRpb24gfSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XHJcblxyXG4gICAgICAgICAgICBjb25zdHJ1Y3RvcihlZGl0b3I6IEVkaXRvclZpZXcpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZWRpdG9yID0gZWRpdG9yO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGFzeW5jIGNvbXB1dGUodG9rZW5zOiBUb2tlblNwZWNbXSkge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2codGhpcy5yZXBsYWNlcnMpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcmVwbGFjZTogUmFuZ2U8RGVjb3JhdGlvbj5bXSA9IFtdO1xyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgdG9rZW4gb2YgdG9rZW5zKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9uZWVkIHRvIGFkZCBpbiBhZGRpdGlvbmFsIGxvY2F0aW9ucyB0byB0aGUgY2FjaGVzIHNvIHRoYXQgdGhlIHJldmVhbCB0cmFuc2FjdGlvbiB3aWxsIHByb3Blcmx5IHN1cmZhY2UgdGhlbVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBkZWNvID0gRGVjb3JhdGlvbi5yZXBsYWNlKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsb2M6IHRva2VuLmxvY1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBtYXJrZXIgPSBEZWNvcmF0aW9uLm1hcmsoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmNsdXNpdmU6IHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IE9iamVjdC5mcm9tRW50cmllcyh0b2tlbi5hdHRyaWJ1dGVzKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbG9jOiB0b2tlbi5sb2NcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgcmVwbGFjZS5wdXNoKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWNvLnJhbmdlKHRva2VuLmZyb20sIHRva2VuLnRvKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWFya2VyLnJhbmdlKHRva2VuLmxvYy5mcm9tLCB0b2tlbi5sb2MudG8pXHJcbiAgICAgICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBEZWNvcmF0aW9uLnNldChyZXBsYWNlLCB0cnVlKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgYXN5bmMgdXBkYXRlRGVjb3ModG9rZW5zOiBUb2tlblNwZWNbXSk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcmVwbGFjZXJzID0gYXdhaXQgdGhpcy5jb21wdXRlKHRva2Vucyk7XHJcbiAgICAgICAgICAgICAgICAvLyBpZiBvdXIgY29tcHV0ZSBmdW5jdGlvbiByZXR1cm5lZCBub3RoaW5nIGFuZCB0aGUgc3RhdGUgZmllbGQgc3RpbGwgaGFzIGRlY29yYXRpb25zLCBjbGVhciB0aGVtIG91dFxyXG4gICAgICAgICAgICAgICAgaWYgKHJlcGxhY2UgfHwgdGhpcy5lZGl0b3Iuc3RhdGUuZmllbGQoZmllbGQpLnNpemUpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmVkaXRvci5kaXNwYXRjaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVmZmVjdHM6IFtyZXBsYWNlLm9mKHJlcGxhY2VycyA/PyBEZWNvcmF0aW9uLm5vbmUpXVxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCBwbHVnaW4gPSBWaWV3UGx1Z2luLmZyb21DbGFzcyhcclxuICAgICAgICAgICAgY2xhc3Mge1xyXG4gICAgICAgICAgICAgICAgbWFuYWdlcjogU3RhdGVmdWxEZWNvcmF0aW9uU2V0O1xyXG4gICAgICAgICAgICAgICAgc291cmNlID0gZmFsc2U7XHJcblxyXG4gICAgICAgICAgICAgICAgY29uc3RydWN0b3IodmlldzogRWRpdG9yVmlldykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWFuYWdlciA9IG5ldyBTdGF0ZWZ1bERlY29yYXRpb25TZXQodmlldyk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5idWlsZCh2aWV3KTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB1cGRhdGUodXBkYXRlOiBWaWV3VXBkYXRlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc0xpdmVQcmV2aWV3KHVwZGF0ZS52aWV3LnN0YXRlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5zb3VyY2UgPT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc291cmNlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubWFuYWdlci51cGRhdGVEZWNvcyhbXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZS5kb2NDaGFuZ2VkIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZS52aWV3cG9ydENoYW5nZWQgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlLnNlbGVjdGlvblNldCB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNvdXJjZSA9PSB0cnVlXHJcbiAgICAgICAgICAgICAgICAgICAgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc291cmNlID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYnVpbGQodXBkYXRlLnZpZXcpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBkZXN0cm95KCkge31cclxuXHJcbiAgICAgICAgICAgICAgICBidWlsZCh2aWV3OiBFZGl0b3JWaWV3KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc0xpdmVQcmV2aWV3KHZpZXcuc3RhdGUpKSByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdGFyZ2V0RWxlbWVudHM6IFRva2VuU3BlY1tdID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgeyBmcm9tLCB0byB9IG9mIHZpZXcudmlzaWJsZVJhbmdlcykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiXHVEODNEXHVERTgwIH4gZmlsZTogbWFpbi50cyB+IGxpbmUgMjE2IH4gZnJvbVwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJvbVxyXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0cmVlID0gc3ludGF4VHJlZSh2aWV3LnN0YXRlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHJlZS5pdGVyYXRlKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyb20sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0byxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVudGVyOiAodHlwZSwgZnJvbSwgdG8pID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0b2tlblByb3BzID1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZS5wcm9wKHRva2VuQ2xhc3NOb2RlUHJvcCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHByb3BzID0gbmV3IFNldCh0b2tlblByb3BzPy5zcGxpdChcIiBcIikpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvcHMuaGFzKFwiaG1kLWNvZGVibG9ja1wiKSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAhcHJvcHMuaGFzKFwiZm9ybWF0dGluZy1jb2RlLWJsb2NrXCIpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgb3JpZ2luYWwgPSB2aWV3LnN0YXRlLmRvYy5zbGljZVN0cmluZyhcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJvbSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL1RPRE86IFlvdSB3aWxsIHByb2JhYmx5IG5lZWQgdG8gaWRlbnRpZnkgYmxvY2sgdHlwZXMgdG8gZGV0ZXJtaW5lIGZyb20gYW5kIHRvIHZhbHVlcyB0byBhcHBseSBtYXJrLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghUHJvY2Vzc29yLkVORF9SRS50ZXN0KG9yaWdpbmFsKSkgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhcnNlZCA9IFByb2Nlc3Nvci5wYXJzZShvcmlnaW5hbCkgPz8gW107XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiBwYXJzZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBhdHRyaWJ1dGVzLCB0ZXh0IH0gPSBpdGVtO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBlbmQgPVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3JpZ2luYWwuaW5kZXhPZih0ZXh0KSArIHRleHQubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBtYXRjaCA9IG9yaWdpbmFsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAudHJpbSgpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAubWF0Y2goXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3IFJlZ0V4cChcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYFxcXFx7XFxcXHM/JHt0ZXh0fVxccz9cXFxcfSRgLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIm1cIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldEVsZW1lbnRzLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJvbTogZnJvbSArIG1hdGNoLmluZGV4IC0gMSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyb20gK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoLmluZGV4ICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaFswXS5sZW5ndGgsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2M6IHsgZnJvbSwgdG86IGZyb20gKyBlbmQgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBtYXRjaFswXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleDogbWF0Y2guaW5kZXhcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tYW5hZ2VyLnVwZGF0ZURlY29zKHRhcmdldEVsZW1lbnRzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICk7XHJcblxyXG4gICAgICAgIC8vLy8vLy8vLy8vLy8vLy9cclxuICAgICAgICAvLyBVdGlsaXR5IENvZGVcclxuICAgICAgICAvLy8vLy8vLy8vLy8vLy8vXHJcblxyXG4gICAgICAgIGNvbnN0IHJlcGxhY2UgPSBTdGF0ZUVmZmVjdC5kZWZpbmU8RGVjb3JhdGlvblNldD4oKTtcclxuICAgICAgICBjb25zdCBmaWVsZCA9IFN0YXRlRmllbGQuZGVmaW5lPERlY29yYXRpb25TZXQ+KHtcclxuICAgICAgICAgICAgY3JlYXRlKCk6IERlY29yYXRpb25TZXQge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIERlY29yYXRpb24ubm9uZTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgdXBkYXRlKGRlY28sIHRyKTogRGVjb3JhdGlvblNldCB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHIuZWZmZWN0cy5yZWR1Y2UoKGRlY28sIGVmZmVjdCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChlZmZlY3QuaXMocmVwbGFjZSkpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlZmZlY3QudmFsdWUudXBkYXRlKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbHRlcjogKF8sIF9fLCBkZWNvcmF0aW9uKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICFyYW5nZXNJbmNsdWRlKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ci5uZXdTZWxlY3Rpb24ucmFuZ2VzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWNvcmF0aW9uLnNwZWMubG9jLmZyb20sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlY29yYXRpb24uc3BlYy5sb2MudG9cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGVjbztcclxuICAgICAgICAgICAgICAgIH0sIGRlY28ubWFwKHRyLmNoYW5nZXMpKTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgcHJvdmlkZTogKGZpZWxkKSA9PiBFZGl0b3JWaWV3LmRlY29yYXRpb25zLmZyb20oZmllbGQpXHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHJldHVybiBbZmllbGQsIHBsdWdpbl07XHJcbiAgICB9XHJcblxyXG4gICAgaXNMaXZlUHJldmlldyhzdGF0ZTogRWRpdG9yU3RhdGUpIHtcclxuICAgICAgICBpZiAocmVxdWlyZUFwaVZlcnNpb24gJiYgcmVxdWlyZUFwaVZlcnNpb24oXCIwLjEzLjIzXCIpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBzdGF0ZS5maWVsZChlZGl0b3JMaXZlUHJldmlld0ZpZWxkKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zdCBtZCA9IHN0YXRlLmZpZWxkKGVkaXRvclZpZXdGaWVsZCk7XHJcbiAgICAgICAgICAgIGNvbnN0IHsgc3RhdGU6IHZpZXdTdGF0ZSB9ID0gbWQubGVhZi5nZXRWaWV3U3RhdGUoKSA/PyB7fTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiAoXHJcbiAgICAgICAgICAgICAgICB2aWV3U3RhdGUgJiZcclxuICAgICAgICAgICAgICAgIHZpZXdTdGF0ZS5tb2RlID09IFwic291cmNlXCIgJiZcclxuICAgICAgICAgICAgICAgIHZpZXdTdGF0ZS5zb3VyY2UgPT0gZmFsc2VcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgYXN5bmMgb251bmxvYWQoKSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coXCJNYXJrZG93biBBdHRyaWJ1dGVzIHVubG9hZGVkXCIpO1xyXG4gICAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiByYW5nZXNJbmNsdWRlKFxyXG4gICAgcmFuZ2VzOiByZWFkb25seSBTZWxlY3Rpb25SYW5nZVtdLFxyXG4gICAgZnJvbTogbnVtYmVyLFxyXG4gICAgdG86IG51bWJlclxyXG4pIHtcclxuICAgIGZvciAoY29uc3QgcmFuZ2Ugb2YgcmFuZ2VzKSB7XHJcbiAgICAgICAgY29uc3QgeyBmcm9tOiByRnJvbSwgdG86IHJUbyB9ID0gcmFuZ2U7XHJcbiAgICAgICAgaWYgKHJGcm9tID49IGZyb20gJiYgckZyb20gPD0gdG8pIHJldHVybiB0cnVlO1xyXG4gICAgICAgIGlmIChyVG8gPj0gZnJvbSAmJiByVG8gPD0gdG8pIHJldHVybiB0cnVlO1xyXG4gICAgICAgIGlmIChyRnJvbSA8IGZyb20gJiYgclRvID4gdG8pIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG59XHJcbiIsICJpbnRlcmZhY2UgRWxlbWVudFdpdGhBdHRyaWJ1dGVzIHtcclxuICAgIGVsZW1lbnQ/OiBFbGVtZW50O1xyXG4gICAgYXR0cmlidXRlczogW3N0cmluZywgc3RyaW5nXVtdO1xyXG4gICAgdGV4dDogc3RyaW5nO1xyXG4gICAgLyogcmVwbGFjZXI6ICguLi5hcmdzOiBhbnkpID0+IHZvaWQ7ICovXHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFByb2Nlc3NvciB7XHJcbiAgICBzdGF0aWMgQkFTRV9SRSA9IC9cXHtcXDo/WyBdKihbXlxcfVxcbiBdW15cXH1cXG5dKilbIF0qXFx9LztcclxuICAgIHN0YXRpYyBPTkxZX1JFID0gL15cXHtcXDo/WyBdKihbXlxcfVxcbiBdW15cXH1cXG5dKilbIF0qXFx9JC87XHJcbiAgICBzdGF0aWMgQkxPQ0tfUkUgPSAvXFxuWyBdKlxce1xcOj9bIF0qKFteXFx9XFxuIF1bXlxcfVxcbl0qKVsgXSpcXH1bIF0qJC87XHJcbiAgICBzdGF0aWMgRU5EX1JFID0gL1xce1xcOj9bIF0qKFteXFx9XFxuIF1bXlxcfVxcbl0qKVsgXSpcXH0kL207XHJcblxyXG4gICAgY29uc3RydWN0b3IoKSB7fVxyXG5cclxuICAgIHN0YXRpYyBwYXJzZShlbDogSFRNTEVsZW1lbnQpOiBFbGVtZW50V2l0aEF0dHJpYnV0ZXNbXTtcclxuICAgIHN0YXRpYyBwYXJzZShlbDogc3RyaW5nKTogRWxlbWVudFdpdGhBdHRyaWJ1dGVzW107XHJcbiAgICBzdGF0aWMgcGFyc2UoZWw6IHN0cmluZyB8IEhUTUxFbGVtZW50KSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBlbCA9PSBcInN0cmluZ1wiKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvY2Vzc29yKCkucGFyc2VMaW5lKGVsKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb2Nlc3NvcigpLnJlY3Vyc2VBbmRQYXJzZUVsZW1lbnRzKGVsKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBwYXJzZUxpbmUodGV4dDogc3RyaW5nKSB7XHJcbiAgICAgICAgY29uc3QgZWxlbWVudHM6IEVsZW1lbnRXaXRoQXR0cmlidXRlc1tdID0gW107XHJcbiAgICAgICAgLy8gUGFyc2Ugb3V0IHRoZSBhdHRyaWJ1dGUgc3RyaW5nLlxyXG4gICAgICAgIGxldCBhdHRyaWJ1dGVfc3RyaW5ncyA9IHRleHQubWF0Y2hBbGwoXHJcbiAgICAgICAgICAgIG5ldyBSZWdFeHAoUHJvY2Vzc29yLkVORF9SRS5zb3VyY2UsIFwiZ21cIilcclxuICAgICAgICApO1xyXG5cclxuICAgICAgICBmb3IgKGNvbnN0IFtfLCBtYXRjaF0gb2YgYXR0cmlidXRlX3N0cmluZ3MpIHtcclxuICAgICAgICAgICAgZWxlbWVudHMucHVzaCh7XHJcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiB0aGlzLmdldEF0dHJzKG1hdGNoKSxcclxuICAgICAgICAgICAgICAgIHRleHQ6IG1hdGNoXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZWxlbWVudHM7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUcmF2ZXJzZXMgYW4gZWxlbWVudHMgY2hpbGQgbm9kZXMgYW5kIHJldHVybnMgdGhlIHRleHQgY29udGVudC5cclxuICAgICAqIEBwYXJhbSBlbCBIVE1MIGVsZW1lbnQgdG8gZ2V0IHRleHQgbm9kZXMgb2YuXHJcbiAgICAgKiBAcmV0dXJucyBUb3AgbGV2ZWwgdGV4dCBvZiB0aGUgZWxlbWVudC5cclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBnZXRUb3BMZXZlbFRleHQoZWw6IEVsZW1lbnQpIHtcclxuICAgICAgICBjb25zdCB0ZXh0cyA9IFtdO1xyXG5cclxuICAgICAgICBmb3IgKGxldCBjaGlsZCBvZiBBcnJheS5mcm9tKGVsLmNoaWxkTm9kZXMpKSB7XHJcbiAgICAgICAgICAgIGlmIChjaGlsZC5ub2RlVHlwZSA9PSBOb2RlLlRFWFRfTk9ERSkge1xyXG4gICAgICAgICAgICAgICAgdGV4dHMucHVzaCgoY2hpbGQgYXMgQ2hhcmFjdGVyRGF0YSkuZGF0YSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB0ZXh0cy5qb2luKFwiXCIpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUGFyc2UgYSBzdHJpbmcgYW5kIHJldHVybiB0aGUgW2tleSwgdmFsdWVdIGF0dHJpYnV0ZSBwYWlycy5cclxuICAgICAqIEBwYXJhbSBzdHIgU3RyaW5nIHRvIHB1bGwgYXR0cmlidXRlcyBmcm9tLlxyXG4gICAgICogQHJldHVybnMge1tzdHJpbmcsIHN0cmluZ119IEFycmF5IG9mIFtrZXksIHZhbHVlXSBhdHRyaWJ1dGUgcGFpcnMuXHJcbiAgICAgKi9cclxuICAgIHByaXZhdGUgZ2V0QXR0cnMoc3RyOiBzdHJpbmcpIHtcclxuICAgICAgICBjb25zdCB0cnlzID0gKHN0ciA/PyBcIlwiKVxyXG4gICAgICAgICAgICAvLyBTcGxpdCB0aGUgc3RyaW5nIGF0IHNwYWNlcyB0aGF0IGFyZSAqbm90KiBiZXR3ZWVuIHF1b3Rlcy5cclxuICAgICAgICAgICAgLnNwbGl0KC9cXHMoPz0oPzpbXidcImBdKihbJ1wiYF0pW14nXCJgXSpcXDEpKlteJ1wiYF0qJCkvKVxyXG4gICAgICAgICAgICAvLyBUcmltIHRoZSByZXN1bHRpbmcgc3RyaW5ncy5cclxuICAgICAgICAgICAgLm1hcCgodCkgPT4gdCAmJiB0LnRyaW0oKSlcclxuICAgICAgICAgICAgLy8gUmVtb3ZlIGFueSBzdHJpbmdzIHRoYXQgYXJlIHVuZGVmaW5lZCwgemVybyBsZW5ndGgsIG9yIGp1c3QgYSBxdW90ZSBjaGFyYWN0ZXIuXHJcbiAgICAgICAgICAgIC5maWx0ZXIoKHQpID0+IHQgJiYgdCAhPT0gJ1wiJyAmJiB0ICE9PSBcIidcIiAmJiB0Lmxlbmd0aCk7XHJcblxyXG4gICAgICAgIGlmICghdHJ5cyB8fCAhdHJ5cy5sZW5ndGgpIHJldHVybjtcclxuXHJcbiAgICAgICAgLy8gVGhlc2UgY2hhcmFjdGVycyBhcmUgbm90IGFsbG93ZWQgdG8gYmUgaW5zaWRlIGFuIGF0dHJpYnV0ZSBrZXkuXHJcbiAgICAgICAgY29uc3QgYWxsb3dlZEtleUNoYXJzID0gL1teXFx0XFxuXFxmIC8+XCInPV0vO1xyXG5cclxuICAgICAgICAvLyB7OiBkYXRhPXZhbHVlIH1cclxuICAgICAgICBjb25zdCBrZXlTZXBhcmF0b3IgPSBcIj1cIjtcclxuICAgICAgICAvLyB7IC5jbGFzcyB9XHJcbiAgICAgICAgY29uc3QgY2xhc3NDaGFyID0gXCIuXCI7XHJcbiAgICAgICAgLy8geyAjaWQgfVxyXG4gICAgICAgIC8vIGN1cnJlbnRseSBub3QgYWxsb3dlZCBkdWUgdG8gT2JzaWRpYW4gdGFnXHJcbiAgICAgICAgLy8gVE9ETzogRmlndXJlIG91dCBhIHdvcmthcm91bmQuXHJcbiAgICAgICAgLyogY29uc3QgaWRDaGFyID0gXCIjXCI7ICovXHJcbiAgICAgICAgY29uc3QgYXR0cnM6IEFycmF5PFtzdHJpbmcsIHN0cmluZ10+ID0gW107XHJcblxyXG4gICAgICAgIGZvciAobGV0IHBhaXIgb2YgdHJ5cykge1xyXG4gICAgICAgICAgICBpZiAoIXBhaXIgfHwgIXBhaXIubGVuZ3RoKSBjb250aW51ZTtcclxuXHJcbiAgICAgICAgICAgIC8vI2lkXHJcbiAgICAgICAgICAgIC8qIGlmIChwYWlyLmNoYXJBdCgwKSA9PT0gaWRDaGFyKSB7XHJcbiAgICAgICAgICAgICAgICBhdHRycy5wdXNoKFtcImlkXCIsIHBhaXIuc2xpY2UoMSldKTtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9ICovXHJcblxyXG4gICAgICAgICAgICAvLyAuY2xhc3NcclxuICAgICAgICAgICAgaWYgKHBhaXIuY2hhckF0KDApID09PSBjbGFzc0NoYXIpIHtcclxuICAgICAgICAgICAgICAgIGF0dHJzLnB1c2goW1wiY2xhc3NcIiwgcGFpci5zbGljZSgxKV0pO1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIGRhdGE9dmFsdWVcclxuICAgICAgICAgICAgaWYgKFxyXG4gICAgICAgICAgICAgICAgbmV3IFJlZ0V4cChrZXlTZXBhcmF0b3IpLnRlc3QocGFpcikgJiZcclxuICAgICAgICAgICAgICAgIGFsbG93ZWRLZXlDaGFycy50ZXN0KHBhaXIuc2xpY2UoMCwgcGFpci5pbmRleE9mKGtleVNlcGFyYXRvcikpKVxyXG4gICAgICAgICAgICApIHtcclxuICAgICAgICAgICAgICAgIGF0dHJzLnB1c2goWy4uLnBhaXIuc3BsaXQoa2V5U2VwYXJhdG9yLCAyKV0gYXMgW1xyXG4gICAgICAgICAgICAgICAgICAgIHN0cmluZyxcclxuICAgICAgICAgICAgICAgICAgICBzdHJpbmdcclxuICAgICAgICAgICAgICAgIF0pO1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIGNoZWNrZWRcclxuICAgICAgICAgICAgYXR0cnMucHVzaChbcGFpciwgbnVsbF0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYXR0cnM7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGVsIEhUTUwgZWxlbWVudCB0byBwYXJzZS5cclxuICAgICAqIEByZXR1cm5zIHtFbGVtZW50V2l0aEF0dHJpYnV0ZXN9IEVsZW1lbnQsIGF0dHJpYnV0ZXMgdG8gYXBwbHksIG9yaWdpbmFsIG1hdGNoZWQgdGV4dC5cclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSByZWN1cnNlQW5kUGFyc2VFbGVtZW50cyhlbDogSFRNTEVsZW1lbnQpOiBFbGVtZW50V2l0aEF0dHJpYnV0ZXNbXSB7XHJcbiAgICAgICAgY29uc3QgZWxlbWVudHM6IEVsZW1lbnRXaXRoQXR0cmlidXRlc1tdID0gW107XHJcblxyXG4gICAgICAgIC8vIFRleHQgY29udGVudCBvZiB0aGlzIG5vZGUgYW5kICpub3QqIHRoZSBjaGlsZHJlbi5cclxuICAgICAgICBjb25zdCB0ZXh0ID0gdGhpcy5nZXRUb3BMZXZlbFRleHQoZWwpO1xyXG5cclxuICAgICAgICBpZiAoUHJvY2Vzc29yLkJMT0NLX1JFLnRlc3QodGV4dCkpIHtcclxuICAgICAgICAgICAgLy8gQXR0cmlidXRlcyBzaG91bGQgYXBwbHkgdG8gdGhlIHdob2xlIGJsb2NrLlxyXG5cclxuICAgICAgICAgICAgbGV0IGVsZW1lbnQgPSBlbDtcclxuICAgICAgICAgICAgaWYgKFxyXG4gICAgICAgICAgICAgICAgZWwgaW5zdGFuY2VvZiBIVE1MTElFbGVtZW50IHx8XHJcbiAgICAgICAgICAgICAgICBlbD8ucGFyZW50RWxlbWVudCBpbnN0YW5jZW9mIEhUTUxRdW90ZUVsZW1lbnQgfHxcclxuICAgICAgICAgICAgICAgIGVsPy5oYXNDbGFzcyhcImNhbGxvdXRcIilcclxuICAgICAgICAgICAgKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBOZWVkIHRvIGFwcGx5IGF0dHJpYnV0ZXMgdG8gY29udGFpbmluZyBVTCBpZiBIVE1MTElFbGVtZW50IGhhcyBhIGJsb2NrIGF0dHJpYnV0ZVxyXG4gICAgICAgICAgICAgICAgZWxlbWVudCA9IGVsLnBhcmVudEVsZW1lbnQ7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGxldCBbb3JpZ2luYWwsIGF0dHJpYnV0ZV9zdHJpbmddID1cclxuICAgICAgICAgICAgICAgIHRleHQubWF0Y2goUHJvY2Vzc29yLkJMT0NLX1JFKSA/PyBbXTtcclxuICAgICAgICAgICAgY29uc3QgdG9BZGQgPSB7XHJcbiAgICAgICAgICAgICAgICBlbGVtZW50LFxyXG4gICAgICAgICAgICAgICAgYXR0cmlidXRlczogdGhpcy5nZXRBdHRycyhhdHRyaWJ1dGVfc3RyaW5nKSxcclxuICAgICAgICAgICAgICAgIHRleHQ6IGF0dHJpYnV0ZV9zdHJpbmdcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIGVsZW1lbnRzLnB1c2godG9BZGQpO1xyXG4gICAgICAgICAgICBlbC5pbm5lckhUTUwgPSB0aGlzLnRyeVRvUmVwbGFjZShcclxuICAgICAgICAgICAgICAgIHRvQWRkLmVsZW1lbnQsXHJcbiAgICAgICAgICAgICAgICBlbC5pbm5lckhUTUwsXHJcbiAgICAgICAgICAgICAgICB0b0FkZC5hdHRyaWJ1dGVzLFxyXG4gICAgICAgICAgICAgICAgb3JpZ2luYWxcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgLyogZWwuaW5uZXJIVE1MID0gZWwuaW5uZXJIVE1MLnJlcGxhY2Uob3JpZ2luYWwsIFwiXCIpOyAqL1xyXG5cclxuICAgICAgICAgICAgLy9yZXJ1biBwYXJzZXIgaWYgTEkgZWxlbWVudCB0byBnZXQgaW5saW5lc1xyXG4gICAgICAgICAgICBpZiAoZWwgaW5zdGFuY2VvZiBIVE1MTElFbGVtZW50KSB7XHJcbiAgICAgICAgICAgICAgICBlbGVtZW50cy5wdXNoKC4uLnRoaXMucmVjdXJzZUFuZFBhcnNlRWxlbWVudHMoZWwpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSBpZiAoUHJvY2Vzc29yLkJBU0VfUkUudGVzdCh0ZXh0KSkge1xyXG4gICAgICAgICAgICAvLyBBdHRyaWJ1dGVzIGFyZSBpbmxpbmUuXHJcbiAgICAgICAgICAgIC8vIEdldCB0aGUgdGV4dCBub2RlcyB0aGF0IGNvbnRhaW5zIHRoZSBhdHRyaWJ1dGUgc3RyaW5nLlxyXG4gICAgICAgICAgICBsZXQgdGV4dE5vZGUgPSBBcnJheS5mcm9tKGVsLmNoaWxkTm9kZXMpLmZpbmQoXHJcbiAgICAgICAgICAgICAgICAobm9kZSkgPT5cclxuICAgICAgICAgICAgICAgICAgICBub2RlLm5vZGVUeXBlID09IE5vZGUuVEVYVF9OT0RFICYmXHJcbiAgICAgICAgICAgICAgICAgICAgUHJvY2Vzc29yLkJBU0VfUkUudGVzdCh0ZXh0KVxyXG4gICAgICAgICAgICApO1xyXG5cclxuICAgICAgICAgICAgLy8gRmluZCB0aGUgSFRNTCBlbGVtZW50IHRoYXQgaXMgdGhlIHByZXZpb3VzIHNpYmxpbmcgb2YgdGhlIHRleHQgbm9kZS5cclxuICAgICAgICAgICAgLy8gdGV4dE5vZGUucHJldmlvdXNTaWJsaW5nIGNvdWxkIHJldHVybiBhbm90aGVyIHRleHQgbm9kZS5cclxuICAgICAgICAgICAgLy8gcHJldmlvdXNFbGVtZW50U2libGluZyBkb2VzIG5vdCBleGlzdGluZyBvbiBhIHRleHQgbm9kZS5cclxuICAgICAgICAgICAgbGV0IHNpYmxpbmcgPVxyXG4gICAgICAgICAgICAgICAgQXJyYXkuZnJvbShlbC5jaGlsZHJlbikuZmluZChcclxuICAgICAgICAgICAgICAgICAgICAobm9kZSkgPT4gbm9kZS5uZXh0U2libGluZyA9PSB0ZXh0Tm9kZVxyXG4gICAgICAgICAgICAgICAgKSA/PyBlbDtcclxuXHJcbiAgICAgICAgICAgIC8vIENvbGxhcHNpYmxlIGVsZW1lbnRzIGFyZSBhIHNwZWNpYWwgY2FzZSBkdWUgdG8gdGhlIGNvbGxhcHNlIGhhbmRsZS5cclxuICAgICAgICAgICAgaWYgKHNpYmxpbmcgJiYgc2libGluZy5oYXNDbGFzcyhcImNvbGxhcHNlLWluZGljYXRvclwiKSkge1xyXG4gICAgICAgICAgICAgICAgc2libGluZyA9IHNpYmxpbmcucGFyZW50RWxlbWVudDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKHNpYmxpbmcgJiYgc2libGluZyBpbnN0YW5jZW9mIEhUTUxCUkVsZW1lbnQpIHtcclxuICAgICAgICAgICAgICAgIHNpYmxpbmcgPSBzaWJsaW5nLnBhcmVudEVsZW1lbnQ7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIFBhcnNlIG91dCB0aGUgYXR0cmlidXRlIHN0cmluZy5cclxuICAgICAgICAgICAgbGV0IFtvcmlnaW5hbCwgYXR0cmlidXRlX3N0cmluZ10gPVxyXG4gICAgICAgICAgICAgICAgdGV4dC5tYXRjaChQcm9jZXNzb3IuQkFTRV9SRSkgPz8gW107XHJcblxyXG4gICAgICAgICAgICBjb25zdCB0b0FkZCA9IHtcclxuICAgICAgICAgICAgICAgIGVsZW1lbnQ6IHNpYmxpbmcsXHJcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiB0aGlzLmdldEF0dHJzKGF0dHJpYnV0ZV9zdHJpbmcpLFxyXG4gICAgICAgICAgICAgICAgdGV4dDogYXR0cmlidXRlX3N0cmluZ1xyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgZWxlbWVudHMucHVzaCh0b0FkZCk7XHJcblxyXG4gICAgICAgICAgICAvLyBSZW1vdmUgdGhlIG9yaWdpbmFsIGF0dHJpYnV0ZSBzdHJpbmcgZnJvbSB0aGUgdGV4dCBjb250ZW50LlxyXG4gICAgICAgICAgICB0ZXh0Tm9kZS50ZXh0Q29udGVudCA9IHRoaXMudHJ5VG9SZXBsYWNlKFxyXG4gICAgICAgICAgICAgICAgdG9BZGQuZWxlbWVudCxcclxuICAgICAgICAgICAgICAgIHRleHROb2RlLnRleHRDb250ZW50LFxyXG4gICAgICAgICAgICAgICAgdG9BZGQuYXR0cmlidXRlcyxcclxuICAgICAgICAgICAgICAgIG9yaWdpbmFsXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIC8qIHRleHROb2RlLnRleHRDb250ZW50ID0gdGV4dE5vZGUudGV4dENvbnRlbnQucmVwbGFjZShvcmlnaW5hbCwgXCJcIik7ICovXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBSZWN1cnNpdmVseSBmaW5kIGFsbCBhdHRyaWJ1dGVzIGZyb20gdGhlIGNoaWxkcmVuIG9mIHRoaXMgZWxlbWVudC5cclxuXHJcbiAgICAgICAgZm9yIChsZXQgY2hpbGQgb2YgQXJyYXkuZnJvbShlbC5jaGlsZHJlbikpIHtcclxuICAgICAgICAgICAgaWYgKCEoY2hpbGQgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkpIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICBpZiAoXHJcbiAgICAgICAgICAgICAgICBjaGlsZCBpbnN0YW5jZW9mIEhUTUxQcmVFbGVtZW50IHx8XHJcbiAgICAgICAgICAgICAgICBjaGlsZC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwiY29kZVwiXHJcbiAgICAgICAgICAgIClcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICBlbGVtZW50cy5wdXNoKC4uLnRoaXMucmVjdXJzZUFuZFBhcnNlRWxlbWVudHMoY2hpbGQpKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBlbGVtZW50cztcclxuICAgIH1cclxuICAgIHRyeVRvUmVwbGFjZShcclxuICAgICAgICBlbGVtZW50OiBFbGVtZW50LFxyXG4gICAgICAgIGNvbnRlbnQ6IHN0cmluZyxcclxuICAgICAgICBhdHRyaWJ1dGVzOiBbc3RyaW5nLCBzdHJpbmddW10sXHJcbiAgICAgICAgb3JpZ2luYWw6IHN0cmluZ1xyXG4gICAgKSB7XHJcbiAgICAgICAgaWYgKCFhdHRyaWJ1dGVzIHx8ICFhdHRyaWJ1dGVzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICByZXR1cm4gY29udGVudDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZvciAobGV0IFtrZXksIHZhbHVlXSBvZiBhdHRyaWJ1dGVzKSB7XHJcbiAgICAgICAgICAgIGlmICgha2V5KSBjb250aW51ZTtcclxuICAgICAgICAgICAgaWYgKHZhbHVlKSB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoLyhcInwnKS9nLCBcIlwiKTtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIGlmIChrZXkgPT09IFwiY2xhc3NcIikge1xyXG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuYWRkQ2xhc3Nlcyh2YWx1ZS5zcGxpdChcIiBcIikpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICghdmFsdWUpIHtcclxuICAgICAgICAgICAgICAgICAgICBlbGVtZW50LnNldEF0dHIoa2V5LCB0cnVlKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5zZXRBdHRyKGtleSwgdmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcclxuICAgICAgICAgICAgICAgICAgICBgTWFya2Rvd24gQXR0cmlidXRlczogJHtrZXl9IGlzIG5vdCBhIHZhbGlkIGF0dHJpYnV0ZS5gXHJcbiAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRlbnQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBjb250ZW50LnJlcGxhY2Uob3JpZ2luYWwsIFwiXCIpO1xyXG4gICAgfVxyXG59XHJcbiJdLAogICJtYXBwaW5ncyI6ICI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLHNCQU9PO0FBRVAsa0JBTU87QUFDUCxzQkFBMkI7QUFDM0Is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
